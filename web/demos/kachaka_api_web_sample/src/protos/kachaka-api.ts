// @generated by protobuf-ts 2.9.1
// @generated from protobuf file "kachaka-api.proto" (package "kachaka_api", syntax proto3)
//
//  Copyright 2023 Preferred Robotics, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//     http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
import { ServiceType } from '@protobuf-ts/runtime-rpc';
import type {
  BinaryWriteOptions,
  IBinaryWriter,
  BinaryReadOptions,
  IBinaryReader,
  PartialMessage,
} from '@protobuf-ts/runtime';
import {
  WireType,
  UnknownFieldHandler,
  reflectionMergePartial,
  MESSAGE_TYPE,
  MessageType,
} from '@protobuf-ts/runtime';
/**
 * Common messages
 *
 * @generated from protobuf message kachaka_api.Metadata
 */
export interface Metadata {
  /**
   * @generated from protobuf field: sfixed64 cursor = 1;
   */
  cursor: bigint;
}
/**
 * @generated from protobuf message kachaka_api.Result
 */
export interface Result {
  /**
   * @generated from protobuf field: bool success = 1;
   */
  success: boolean;
  /**
   * @generated from protobuf field: int32 error_code = 3;
   */
  errorCode: number;
}
/**
 * @generated from protobuf message kachaka_api.Error
 */
export interface Error {
  /**
   * @generated from protobuf field: int32 error_code = 2;
   */
  errorCode: number;
}
/**
 * @generated from protobuf message kachaka_api.RosHeader
 */
export interface RosHeader {
  /**
   * @generated from protobuf field: int64 stamp_nsec = 1;
   */
  stampNsec: bigint;
  /**
   * @generated from protobuf field: string frame_id = 2;
   */
  frameId: string;
}
/**
 * @generated from protobuf message kachaka_api.Pose
 */
export interface Pose {
  /**
   * @generated from protobuf field: double x = 1;
   */
  x: number;
  /**
   * @generated from protobuf field: double y = 2;
   */
  y: number;
  /**
   * @generated from protobuf field: double theta = 3;
   */
  theta: number;
}
/**
 * @generated from protobuf message kachaka_api.Vector3
 */
export interface Vector3 {
  /**
   * @generated from protobuf field: double x = 1;
   */
  x: number;
  /**
   * @generated from protobuf field: double y = 2;
   */
  y: number;
  /**
   * @generated from protobuf field: double z = 3;
   */
  z: number;
}
/**
 * @generated from protobuf message kachaka_api.Quaternion
 */
export interface Quaternion {
  /**
   * @generated from protobuf field: double x = 1;
   */
  x: number;
  /**
   * @generated from protobuf field: double y = 2;
   */
  y: number;
  /**
   * @generated from protobuf field: double z = 3;
   */
  z: number;
  /**
   * @generated from protobuf field: double w = 4;
   */
  w: number;
}
/**
 * @generated from protobuf message kachaka_api.Pose3d
 */
export interface Pose3d {
  /**
   * @generated from protobuf field: kachaka_api.Vector3 position = 1;
   */
  position?: Vector3;
  /**
   * @generated from protobuf field: kachaka_api.Quaternion orientation = 2;
   */
  orientation?: Quaternion;
}
/**
 * @generated from protobuf message kachaka_api.Twist
 */
export interface Twist {
  /**
   * @generated from protobuf field: kachaka_api.Vector3 linear = 1;
   */
  linear?: Vector3;
  /**
   * @generated from protobuf field: kachaka_api.Vector3 angular = 2;
   */
  angular?: Vector3;
}
/**
 * @generated from protobuf message kachaka_api.Pose3dWithCovariance
 */
export interface Pose3dWithCovariance {
  /**
   * @generated from protobuf field: kachaka_api.Pose3d pose = 1;
   */
  pose?: Pose3d;
  /**
   * @generated from protobuf field: repeated double covariance = 2;
   */
  covariance: number[];
}
/**
 * @generated from protobuf message kachaka_api.TwistWithCovariance
 */
export interface TwistWithCovariance {
  /**
   * @generated from protobuf field: kachaka_api.Twist twist = 1;
   */
  twist?: Twist;
  /**
   * @generated from protobuf field: repeated double covariance = 2;
   */
  covariance: number[];
}
/**
 * @generated from protobuf message kachaka_api.Map
 */
export interface Map {
  /**
   * @generated from protobuf field: bytes data = 1;
   */
  data: Uint8Array; // uint8[]
  /**
   * @generated from protobuf field: string name = 2;
   */
  name: string;
  /**
   * @generated from protobuf field: double resolution = 3;
   */
  resolution: number;
  /**
   * @generated from protobuf field: int32 width = 4;
   */
  width: number; // larger than 0
  /**
   * @generated from protobuf field: int32 height = 5;
   */
  height: number; // larger than 0
  /**
   * @generated from protobuf field: kachaka_api.Pose origin = 6;
   */
  origin?: Pose;
}
/**
 * @generated from protobuf message kachaka_api.Location
 */
export interface Location {
  /**
   * @generated from protobuf field: string id = 1;
   */
  id: string;
  /**
   * @generated from protobuf field: string name = 2;
   */
  name: string;
  /**
   * @generated from protobuf field: kachaka_api.Pose pose = 3;
   */
  pose?: Pose; // relative to map origin
  /**
   * @generated from protobuf field: kachaka_api.LocationType type = 4;
   */
  type: LocationType;
  /**
   * @generated from protobuf field: bool undock_shelf_aligning_to_wall = 5;
   */
  undockShelfAligningToWall: boolean;
  /**
   * @generated from protobuf field: bool undock_shelf_avoiding_obstacles = 6;
   */
  undockShelfAvoidingObstacles: boolean;
  /**
   * @generated from protobuf field: bool ignore_voice_recognition = 7;
   */
  ignoreVoiceRecognition: boolean;
}
/**
 * @generated from protobuf message kachaka_api.ShelfSize
 */
export interface ShelfSize {
  /**
   * @generated from protobuf field: double width = 1;
   */
  width: number;
  /**
   * @generated from protobuf field: double depth = 2;
   */
  depth: number;
  /**
   * @generated from protobuf field: double height = 3;
   */
  height: number;
}
/**
 * @generated from protobuf message kachaka_api.RecognizableName
 */
export interface RecognizableName {
  /**
   * @generated from protobuf field: string name = 1;
   */
  name: string;
  /**
   * @generated from protobuf field: bool deletable = 2;
   */
  deletable: boolean;
}
/**
 * @generated from protobuf message kachaka_api.Shelf
 */
export interface Shelf {
  /**
   * @generated from protobuf field: string id = 1;
   */
  id: string;
  /**
   * @generated from protobuf field: string name = 2;
   */
  name: string;
  /**
   * @generated from protobuf field: kachaka_api.Pose pose = 3;
   */
  pose?: Pose; // relative to map origin
  /**
   * @generated from protobuf field: kachaka_api.ShelfSize size = 4;
   */
  size?: ShelfSize;
  /**
   * @generated from protobuf field: kachaka_api.ShelfAppearance appearance = 5;
   */
  appearance: ShelfAppearance;
  /**
   * @generated from protobuf field: repeated kachaka_api.RecognizableName recognizable_names = 7;
   */
  recognizableNames: RecognizableName[]; // Recognizable by speech recognition.
  /**
   * @generated from protobuf field: string home_location_id = 8;
   */
  homeLocationId: string;
  /**
   * @generated from protobuf field: kachaka_api.ShelfSpeedMode speed_mode = 9;
   */
  speedMode: ShelfSpeedMode;
  /**
   * @generated from protobuf field: bool ignore_voice_recognition = 10;
   */
  ignoreVoiceRecognition: boolean;
}
/**
 * @generated from protobuf message kachaka_api.RosImu
 */
export interface RosImu {
  /**
   * @generated from protobuf field: kachaka_api.RosHeader header = 1;
   */
  header?: RosHeader;
  /**
   * @generated from protobuf field: kachaka_api.Quaternion orientation = 2;
   */
  orientation?: Quaternion;
  /**
   * @generated from protobuf field: repeated double orientation_covariance = 3;
   */
  orientationCovariance: number[];
  /**
   * @generated from protobuf field: kachaka_api.Vector3 angular_velocity = 4;
   */
  angularVelocity?: Vector3;
  /**
   * @generated from protobuf field: repeated double angular_velocity_covariance = 5;
   */
  angularVelocityCovariance: number[];
  /**
   * @generated from protobuf field: kachaka_api.Vector3 linear_acceleration = 6;
   */
  linearAcceleration?: Vector3;
  /**
   * @generated from protobuf field: repeated double linear_acceleration_covariance = 7;
   */
  linearAccelerationCovariance: number[];
}
/**
 * @generated from protobuf message kachaka_api.RosOdometry
 */
export interface RosOdometry {
  /**
   * @generated from protobuf field: kachaka_api.RosHeader header = 1;
   */
  header?: RosHeader;
  /**
   * @generated from protobuf field: string child_frame_id = 2;
   */
  childFrameId: string;
  /**
   * @generated from protobuf field: kachaka_api.Pose3dWithCovariance pose = 3;
   */
  pose?: Pose3dWithCovariance;
  /**
   * @generated from protobuf field: kachaka_api.TwistWithCovariance twist = 4;
   */
  twist?: TwistWithCovariance;
}
/**
 * @generated from protobuf message kachaka_api.RosLaserScan
 */
export interface RosLaserScan {
  /**
   * @generated from protobuf field: kachaka_api.RosHeader header = 1;
   */
  header?: RosHeader;
  /**
   * @generated from protobuf field: double angle_min = 2;
   */
  angleMin: number;
  /**
   * @generated from protobuf field: double angle_max = 3;
   */
  angleMax: number;
  /**
   * @generated from protobuf field: double angle_increment = 4;
   */
  angleIncrement: number;
  /**
   * @generated from protobuf field: double time_increment = 5;
   */
  timeIncrement: number;
  /**
   * @generated from protobuf field: double scan_time = 6;
   */
  scanTime: number;
  /**
   * @generated from protobuf field: double range_min = 7;
   */
  rangeMin: number;
  /**
   * @generated from protobuf field: double range_max = 8;
   */
  rangeMax: number;
  /**
   * @generated from protobuf field: repeated double ranges = 9;
   */
  ranges: number[];
  /**
   * @generated from protobuf field: repeated double intensities = 10;
   */
  intensities: number[];
}
/**
 * @generated from protobuf message kachaka_api.RegionOfInterest
 */
export interface RegionOfInterest {
  /**
   * @generated from protobuf field: uint32 x_offset = 1;
   */
  xOffset: number;
  /**
   * @generated from protobuf field: uint32 y_offset = 2;
   */
  yOffset: number;
  /**
   * @generated from protobuf field: uint32 height = 3;
   */
  height: number;
  /**
   * @generated from protobuf field: uint32 width = 4;
   */
  width: number;
  /**
   * @generated from protobuf field: bool do_rectify = 5;
   */
  doRectify: boolean;
}
/**
 * @generated from protobuf message kachaka_api.RosCameraInfo
 */
export interface RosCameraInfo {
  /**
   * @generated from protobuf field: kachaka_api.RosHeader header = 1;
   */
  header?: RosHeader;
  /**
   * @generated from protobuf field: uint32 height = 2;
   */
  height: number;
  /**
   * @generated from protobuf field: uint32 width = 3;
   */
  width: number;
  /**
   * @generated from protobuf field: string distortion_model = 4;
   */
  distortionModel: string;
  /**
   * @generated from protobuf field: repeated double D = 5 [json_name = "D"];
   */
  d: number[];
  /**
   * @generated from protobuf field: repeated double K = 6 [json_name = "K"];
   */
  k: number[];
  /**
   * @generated from protobuf field: repeated double R = 7 [json_name = "R"];
   */
  r: number[];
  /**
   * @generated from protobuf field: repeated double P = 8 [json_name = "P"];
   */
  p: number[];
  /**
   * @generated from protobuf field: uint32 binning_x = 9;
   */
  binningX: number;
  /**
   * @generated from protobuf field: uint32 binning_y = 10;
   */
  binningY: number;
  /**
   * @generated from protobuf field: kachaka_api.RegionOfInterest roi = 11;
   */
  roi?: RegionOfInterest;
}
/**
 * @generated from protobuf message kachaka_api.RosImage
 */
export interface RosImage {
  /**
   * @generated from protobuf field: kachaka_api.RosHeader header = 1;
   */
  header?: RosHeader;
  /**
   * @generated from protobuf field: uint32 height = 2;
   */
  height: number;
  /**
   * @generated from protobuf field: uint32 width = 3;
   */
  width: number;
  /**
   * @generated from protobuf field: string encoding = 4;
   */
  encoding: string;
  /**
   * @generated from protobuf field: bool is_bigendian = 5;
   */
  isBigendian: boolean;
  /**
   * @generated from protobuf field: uint32 step = 6;
   */
  step: number;
  /**
   * @generated from protobuf field: bytes data = 7;
   */
  data: Uint8Array;
}
/**
 * @generated from protobuf message kachaka_api.RosCompressedImage
 */
export interface RosCompressedImage {
  /**
   * @generated from protobuf field: kachaka_api.RosHeader header = 1;
   */
  header?: RosHeader;
  /**
   * @generated from protobuf field: string format = 2;
   */
  format: string;
  /**
   * @generated from protobuf field: bytes data = 3;
   */
  data: Uint8Array;
}
/**
 * @generated from protobuf message kachaka_api.ObjectDetection
 */
export interface ObjectDetection {
  /**
   * @generated from protobuf field: uint32 label = 1;
   */
  label: number;
  /**
   * @generated from protobuf field: kachaka_api.RegionOfInterest roi = 2;
   */
  roi?: RegionOfInterest;
  /**
   * @generated from protobuf field: float score = 3;
   */
  score: number;
  /**
   * @generated from protobuf field: double distance_median = 4;
   */
  distanceMedian: number;
}
/**
 * Commands
 *
 * @generated from protobuf message kachaka_api.Command
 */
export interface Command {
  /**
   * @generated from protobuf oneof: command
   */
  command:
    | {
        oneofKind: 'moveShelfCommand';
        /**
         * @generated from protobuf field: kachaka_api.MoveShelfCommand move_shelf_command = 1;
         */
        moveShelfCommand: MoveShelfCommand;
      }
    | {
        oneofKind: 'returnShelfCommand';
        /**
         * @generated from protobuf field: kachaka_api.ReturnShelfCommand return_shelf_command = 2;
         */
        returnShelfCommand: ReturnShelfCommand;
      }
    | {
        oneofKind: 'undockShelfCommand';
        /**
         * @generated from protobuf field: kachaka_api.UndockShelfCommand undock_shelf_command = 5;
         */
        undockShelfCommand: UndockShelfCommand;
      }
    | {
        oneofKind: 'moveToLocationCommand';
        /**
         * @generated from protobuf field: kachaka_api.MoveToLocationCommand move_to_location_command = 7;
         */
        moveToLocationCommand: MoveToLocationCommand;
      }
    | {
        oneofKind: 'returnHomeCommand';
        /**
         * @generated from protobuf field: kachaka_api.ReturnHomeCommand return_home_command = 8;
         */
        returnHomeCommand: ReturnHomeCommand;
      }
    | {
        oneofKind: 'dockShelfCommand';
        /**
         * @generated from protobuf field: kachaka_api.DockShelfCommand dock_shelf_command = 9;
         */
        dockShelfCommand: DockShelfCommand;
      }
    | {
        oneofKind: 'speakCommand';
        /**
         * @generated from protobuf field: kachaka_api.SpeakCommand speak_command = 12;
         */
        speakCommand: SpeakCommand;
      }
    | {
        oneofKind: 'moveToPoseCommand';
        /**
         * @generated from protobuf field: kachaka_api.MoveToPoseCommand move_to_pose_command = 13;
         */
        moveToPoseCommand: MoveToPoseCommand;
      }
    | {
        oneofKind: undefined;
      };
}
/**
 * @generated from protobuf message kachaka_api.MoveShelfCommand
 */
export interface MoveShelfCommand {
  /**
   * @generated from protobuf field: string target_shelf_id = 1;
   */
  targetShelfId: string;
  /**
   * @generated from protobuf field: string destination_location_id = 2;
   */
  destinationLocationId: string;
}
/**
 * @generated from protobuf message kachaka_api.ReturnShelfCommand
 */
export interface ReturnShelfCommand {
  /**
   * @generated from protobuf field: string target_shelf_id = 1;
   */
  targetShelfId: string;
}
/**
 * @generated from protobuf message kachaka_api.UndockShelfCommand
 */
export interface UndockShelfCommand {
  /**
   * @generated from protobuf field: string target_shelf_id = 1;
   */
  targetShelfId: string;
}
/**
 * @generated from protobuf message kachaka_api.MoveToLocationCommand
 */
export interface MoveToLocationCommand {
  /**
   * @generated from protobuf field: string target_location_id = 1;
   */
  targetLocationId: string;
}
/**
 * @generated from protobuf message kachaka_api.ReturnHomeCommand
 */
export interface ReturnHomeCommand {}
/**
 * @generated from protobuf message kachaka_api.DockShelfCommand
 */
export interface DockShelfCommand {}
/**
 * @generated from protobuf message kachaka_api.SpeakCommand
 */
export interface SpeakCommand {
  /**
   * @generated from protobuf field: string text = 1;
   */
  text: string;
}
/**
 * @generated from protobuf message kachaka_api.MoveToPoseCommand
 */
export interface MoveToPoseCommand {
  /**
   * @generated from protobuf field: double x = 1;
   */
  x: number;
  /**
   * @generated from protobuf field: double y = 2;
   */
  y: number;
  /**
   * @generated from protobuf field: double yaw = 3;
   */
  yaw: number;
}
/**
 * Requests and Responses
 *
 * @generated from protobuf message kachaka_api.EmptyRequest
 */
export interface EmptyRequest {}
/**
 * @generated from protobuf message kachaka_api.GetRequest
 */
export interface GetRequest {
  /**
   * @generated from protobuf field: kachaka_api.Metadata metadata = 1;
   */
  metadata?: Metadata;
}
/**
 * @generated from protobuf message kachaka_api.GetRobotSerialNumberResponse
 */
export interface GetRobotSerialNumberResponse {
  /**
   * @generated from protobuf field: kachaka_api.Metadata metadata = 1;
   */
  metadata?: Metadata;
  /**
   * @generated from protobuf field: string serial_number = 2;
   */
  serialNumber: string;
}
/**
 * @generated from protobuf message kachaka_api.GetRobotVersionResponse
 */
export interface GetRobotVersionResponse {
  /**
   * @generated from protobuf field: kachaka_api.Metadata metadata = 1;
   */
  metadata?: Metadata;
  /**
   * @generated from protobuf field: string version = 2;
   */
  version: string;
}
/**
 * @generated from protobuf message kachaka_api.GetRobotPoseResponse
 */
export interface GetRobotPoseResponse {
  /**
   * @generated from protobuf field: kachaka_api.Metadata metadata = 1;
   */
  metadata?: Metadata;
  /**
   * @generated from protobuf field: kachaka_api.Pose pose = 2;
   */
  pose?: Pose;
}
/**
 * @generated from protobuf message kachaka_api.GetPngMapResponse
 */
export interface GetPngMapResponse {
  /**
   * @generated from protobuf field: kachaka_api.Metadata metadata = 1;
   */
  metadata?: Metadata;
  /**
   * @generated from protobuf field: kachaka_api.Map map = 2;
   */
  map?: Map;
}
/**
 * @generated from protobuf message kachaka_api.GetObjectDetectionResponse
 */
export interface GetObjectDetectionResponse {
  /**
   * @generated from protobuf field: kachaka_api.Metadata metadata = 1;
   */
  metadata?: Metadata;
  /**
   * @generated from protobuf field: kachaka_api.RosHeader header = 2;
   */
  header?: RosHeader;
  /**
   * @generated from protobuf field: repeated kachaka_api.ObjectDetection objects = 3;
   */
  objects: ObjectDetection[];
}
/**
 * @generated from protobuf message kachaka_api.GetRosImuResponse
 */
export interface GetRosImuResponse {
  /**
   * @generated from protobuf field: kachaka_api.Metadata metadata = 1;
   */
  metadata?: Metadata;
  /**
   * @generated from protobuf field: kachaka_api.RosImu imu = 2;
   */
  imu?: RosImu;
}
/**
 * @generated from protobuf message kachaka_api.GetRosOdometryResponse
 */
export interface GetRosOdometryResponse {
  /**
   * @generated from protobuf field: kachaka_api.Metadata metadata = 1;
   */
  metadata?: Metadata;
  /**
   * @generated from protobuf field: kachaka_api.RosOdometry odometry = 2;
   */
  odometry?: RosOdometry;
}
/**
 * @generated from protobuf message kachaka_api.GetRosLaserScanResponse
 */
export interface GetRosLaserScanResponse {
  /**
   * @generated from protobuf field: kachaka_api.Metadata metadata = 1;
   */
  metadata?: Metadata;
  /**
   * @generated from protobuf field: kachaka_api.RosLaserScan scan = 2;
   */
  scan?: RosLaserScan;
}
/**
 * @generated from protobuf message kachaka_api.GetFrontCameraRosCameraInfoResponse
 */
export interface GetFrontCameraRosCameraInfoResponse {
  /**
   * @generated from protobuf field: kachaka_api.Metadata metadata = 1;
   */
  metadata?: Metadata;
  /**
   * @generated from protobuf field: kachaka_api.RosCameraInfo camera_info = 2;
   */
  cameraInfo?: RosCameraInfo;
}
/**
 * @generated from protobuf message kachaka_api.GetFrontCameraRosImageResponse
 */
export interface GetFrontCameraRosImageResponse {
  /**
   * @generated from protobuf field: kachaka_api.Metadata metadata = 1;
   */
  metadata?: Metadata;
  /**
   * @generated from protobuf field: kachaka_api.RosImage image = 2;
   */
  image?: RosImage;
}
/**
 * @generated from protobuf message kachaka_api.GetFrontCameraRosCompressedImageResponse
 */
export interface GetFrontCameraRosCompressedImageResponse {
  /**
   * @generated from protobuf field: kachaka_api.Metadata metadata = 1;
   */
  metadata?: Metadata;
  /**
   * @generated from protobuf field: kachaka_api.RosCompressedImage image = 2;
   */
  image?: RosCompressedImage;
}
/**
 * @generated from protobuf message kachaka_api.StartCommandRequest
 */
export interface StartCommandRequest {
  /**
   * @generated from protobuf field: kachaka_api.Command command = 1;
   */
  command?: Command;
  /**
   * @generated from protobuf field: bool cancel_all = 2;
   */
  cancelAll: boolean;
  /**
   * @generated from protobuf field: string tts_on_success = 3;
   */
  ttsOnSuccess: string;
  /**
   * @generated from protobuf field: string title = 4;
   */
  title: string;
}
/**
 * @generated from protobuf message kachaka_api.StartCommandResponse
 */
export interface StartCommandResponse {
  /**
   * @generated from protobuf field: kachaka_api.Result result = 1;
   */
  result?: Result;
  /**
   * @generated from protobuf field: string command_id = 2;
   */
  commandId: string;
}
/**
 * @generated from protobuf message kachaka_api.CancelCommandResponse
 */
export interface CancelCommandResponse {
  /**
   * @generated from protobuf field: kachaka_api.Result result = 1;
   */
  result?: Result;
  /**
   * @generated from protobuf field: kachaka_api.Command command = 2;
   */
  command?: Command;
}
/**
 * @generated from protobuf message kachaka_api.GetCommandStateResponse
 */
export interface GetCommandStateResponse {
  /**
   * @generated from protobuf field: kachaka_api.Metadata metadata = 1;
   */
  metadata?: Metadata;
  /**
   * @generated from protobuf field: kachaka_api.CommandState state = 2;
   */
  state: CommandState;
  /**
   * @generated from protobuf field: kachaka_api.Command command = 3;
   */
  command?: Command;
}
/**
 * @generated from protobuf message kachaka_api.GetLastCommandResultResponse
 */
export interface GetLastCommandResultResponse {
  /**
   * @generated from protobuf field: kachaka_api.Metadata metadata = 1;
   */
  metadata?: Metadata;
  /**
   * @generated from protobuf field: kachaka_api.Result result = 2;
   */
  result?: Result; // Empty if there is no last command
  /**
   * @generated from protobuf field: kachaka_api.Command command = 3;
   */
  command?: Command;
}
/**
 * @generated from protobuf message kachaka_api.GetLocationsResponse
 */
export interface GetLocationsResponse {
  /**
   * @generated from protobuf field: kachaka_api.Metadata metadata = 1;
   */
  metadata?: Metadata;
  /**
   * @generated from protobuf field: repeated kachaka_api.Location locations = 2;
   */
  locations: Location[];
  /**
   * @generated from protobuf field: string default_location_id = 3;
   */
  defaultLocationId: string;
}
/**
 * @generated from protobuf message kachaka_api.GetShelvesResponse
 */
export interface GetShelvesResponse {
  /**
   * @generated from protobuf field: kachaka_api.Metadata metadata = 1;
   */
  metadata?: Metadata;
  /**
   * @generated from protobuf field: repeated kachaka_api.Shelf shelves = 2;
   */
  shelves: Shelf[];
}
/**
 * @generated from protobuf message kachaka_api.SetAutoHomingEnabledRequest
 */
export interface SetAutoHomingEnabledRequest {
  /**
   * @generated from protobuf field: bool enable = 1;
   */
  enable: boolean;
}
/**
 * @generated from protobuf message kachaka_api.SetAutoHomingEnabledResponse
 */
export interface SetAutoHomingEnabledResponse {
  /**
   * @generated from protobuf field: kachaka_api.Result result = 1;
   */
  result?: Result;
}
/**
 * @generated from protobuf message kachaka_api.GetAutoHomingEnabledResponse
 */
export interface GetAutoHomingEnabledResponse {
  /**
   * @generated from protobuf field: kachaka_api.Metadata metadata = 1;
   */
  metadata?: Metadata;
  /**
   * @generated from protobuf field: bool enabled = 2;
   */
  enabled: boolean;
}
/**
 * @generated from protobuf message kachaka_api.SetManualControlEnabledRequest
 */
export interface SetManualControlEnabledRequest {
  /**
   * @generated from protobuf field: bool enable = 1;
   */
  enable: boolean;
  /**
   * @generated from protobuf field: bool use_shelf_registration = 2;
   */
  useShelfRegistration: boolean; // effective only if enable==true
}
/**
 * @generated from protobuf message kachaka_api.SetManualControlEnabledResponse
 */
export interface SetManualControlEnabledResponse {
  /**
   * @generated from protobuf field: kachaka_api.Result result = 1;
   */
  result?: Result;
}
/**
 * @generated from protobuf message kachaka_api.GetManualControlEnabledResponse
 */
export interface GetManualControlEnabledResponse {
  /**
   * @generated from protobuf field: kachaka_api.Metadata metadata = 1;
   */
  metadata?: Metadata;
  /**
   * @generated from protobuf field: bool enabled = 2;
   */
  enabled: boolean;
}
/**
 * @generated from protobuf message kachaka_api.SetRobotVelocityRequest
 */
export interface SetRobotVelocityRequest {
  /**
   * @generated from protobuf field: double linear = 1;
   */
  linear: number; // [-1, 1]
  /**
   * @generated from protobuf field: double angular = 2;
   */
  angular: number; // [-1, 1]
}
/**
 * @generated from protobuf message kachaka_api.SetRobotVelocityResponse
 */
export interface SetRobotVelocityResponse {
  /**
   * @generated from protobuf field: kachaka_api.Result result = 1;
   */
  result?: Result;
}
/**
 * History
 *
 * @generated from protobuf message kachaka_api.History
 */
export interface History {
  /**
   * @generated from protobuf field: string id = 1;
   */
  id: string;
  /**
   * @generated from protobuf field: kachaka_api.Command command = 4;
   */
  command?: Command;
  /**
   * @generated from protobuf field: bool success = 5;
   */
  success: boolean;
  /**
   * @generated from protobuf field: int32 error_code = 6;
   */
  errorCode: number;
  /**
   * @generated from protobuf field: int64 command_executed_time = 7;
   */
  commandExecutedTime: bigint;
}
/**
 * @generated from protobuf message kachaka_api.GetHistoryListResponse
 */
export interface GetHistoryListResponse {
  /**
   * @generated from protobuf field: kachaka_api.Metadata metadata = 1;
   */
  metadata?: Metadata;
  /**
   * @generated from protobuf field: repeated kachaka_api.History histories = 2;
   */
  histories: History[];
}
/**
 * @generated from protobuf enum kachaka_api.LocationType
 */
export enum LocationType {
  /**
   * normal location
   *
   * @generated from protobuf enum value: LOCATION_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,
  /**
   * @generated from protobuf enum value: LOCATION_TYPE_CHARGER = 1;
   */
  CHARGER = 1,
  /**
   * @generated from protobuf enum value: LOCATION_TYPE_SHELF_HOME = 2;
   */
  SHELF_HOME = 2,
}
/**
 * @generated from protobuf enum kachaka_api.ShelfAppearance
 */
export enum ShelfAppearance {
  /**
   * @generated from protobuf enum value: SHELF_APPEARANCE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,
  /**
   * @generated from protobuf enum value: SHELF_APPEARANCE_DEFAULT_SHELF = 1;
   */
  DEFAULT_SHELF = 1,
  /**
   * @generated from protobuf enum value: SHELF_APPEARANCE_KACHAKA_SHELF_3DRAWERS = 2;
   */
  KACHAKA_SHELF_3DRAWERS = 2,
  /**
   * @generated from protobuf enum value: SHELF_APPEARANCE_KACHAKA_SHELF_2DRAWERS = 3;
   */
  KACHAKA_SHELF_2DRAWERS = 3,
}
/**
 * @generated from protobuf enum kachaka_api.ShelfSpeedMode
 */
export enum ShelfSpeedMode {
  /**
   * @generated from protobuf enum value: SHELF_SPEED_MODE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,
  /**
   * @generated from protobuf enum value: SHELF_SPEED_MODE_LOW = 1;
   */
  LOW = 1,
  /**
   * @generated from protobuf enum value: SHELF_SPEED_MODE_NORMAL = 2;
   */
  NORMAL = 2,
}
/**
 * @generated from protobuf enum kachaka_api.ObjectLabel
 */
export enum ObjectLabel {
  /**
   * @generated from protobuf enum value: OBJECT_LABEL_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,
  /**
   * @generated from protobuf enum value: OBJECT_LABEL_PERSON = 1;
   */
  PERSON = 1,
  /**
   * @generated from protobuf enum value: OBJECT_LABEL_SHELF = 2;
   */
  SHELF = 2,
  /**
   * @generated from protobuf enum value: OBJECT_LABEL_CHARGER = 3;
   */
  CHARGER = 3,
  /**
   * @generated from protobuf enum value: OBJECT_LABEL_DOOR = 4;
   */
  DOOR = 4,
}
/**
 * @generated from protobuf enum kachaka_api.CommandState
 */
export enum CommandState {
  /**
   * @generated from protobuf enum value: COMMAND_STATE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,
  /**
   * No command is running. Waiting for requests.
   *
   * @generated from protobuf enum value: COMMAND_STATE_PENDING = 1;
   */
  PENDING = 1,
  /**
   * @generated from protobuf enum value: COMMAND_STATE_RUNNING = 2;
   */
  RUNNING = 2,
}
// @generated message type with reflection information, may provide speed optimized methods
class Metadata$Type extends MessageType<Metadata> {
  constructor() {
    super('kachaka_api.Metadata', [
      {
        no: 1,
        name: 'cursor',
        kind: 'scalar',
        T: 16 /* ScalarType.SFIXED64 */,
        L: 0 /* LongType.BIGINT */,
      },
    ]);
  }

  create(value?: PartialMessage<Metadata>): Metadata {
    const message = { cursor: 0n };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined) {
      reflectionMergePartial<Metadata>(this, message, value);
    }
    return message;
  }

  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: Metadata,
  ): Metadata {
    const message = target ?? this.create();
    const end = reader.pos + length;
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* sfixed64 cursor */ 1:
          message.cursor = reader.sfixed64().toBigInt();
          break;
        default:
          const u = options.readUnknownField;
          if (u === 'throw') {
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          }
          const d = reader.skip(wireType);
          if (u !== false) {
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
          }
      }
    }
    return message;
  }

  internalBinaryWrite(
    message: Metadata,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* sfixed64 cursor = 1; */
    if (message.cursor !== 0n) {
      writer.tag(1, WireType.Bit64).sfixed64(message.cursor);
    }
    const u = options.writeUnknownFields;
    if (u !== false) {
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    }
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message kachaka_api.Metadata
 */
export const Metadata = new Metadata$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Result$Type extends MessageType<Result> {
  constructor() {
    super('kachaka_api.Result', [
      { no: 1, name: 'success', kind: 'scalar', T: 8 /* ScalarType.BOOL */ },
      {
        no: 3,
        name: 'error_code',
        kind: 'scalar',
        T: 5 /* ScalarType.INT32 */,
      },
    ]);
  }

  create(value?: PartialMessage<Result>): Result {
    const message = { success: false, errorCode: 0 };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined) {
      reflectionMergePartial<Result>(this, message, value);
    }
    return message;
  }

  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: Result,
  ): Result {
    const message = target ?? this.create();
    const end = reader.pos + length;
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bool success */ 1:
          message.success = reader.bool();
          break;
        case /* int32 error_code */ 3:
          message.errorCode = reader.int32();
          break;
        default:
          const u = options.readUnknownField;
          if (u === 'throw') {
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          }
          const d = reader.skip(wireType);
          if (u !== false) {
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
          }
      }
    }
    return message;
  }

  internalBinaryWrite(
    message: Result,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* bool success = 1; */
    if (message.success) {
      writer.tag(1, WireType.Varint).bool(message.success);
    }
    /* int32 error_code = 3; */
    if (message.errorCode !== 0) {
      writer.tag(3, WireType.Varint).int32(message.errorCode);
    }
    const u = options.writeUnknownFields;
    if (u !== false) {
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    }
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message kachaka_api.Result
 */
export const Result = new Result$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Error$Type extends MessageType<Error> {
  constructor() {
    super('kachaka_api.Error', [
      {
        no: 2,
        name: 'error_code',
        kind: 'scalar',
        T: 5 /* ScalarType.INT32 */,
      },
    ]);
  }

  create(value?: PartialMessage<Error>): Error {
    const message = { errorCode: 0 };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined) {
      reflectionMergePartial<Error>(this, message, value);
    }
    return message;
  }

  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: Error,
  ): Error {
    const message = target ?? this.create();
    const end = reader.pos + length;
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* int32 error_code */ 2:
          message.errorCode = reader.int32();
          break;
        default:
          const u = options.readUnknownField;
          if (u === 'throw') {
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          }
          const d = reader.skip(wireType);
          if (u !== false) {
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
          }
      }
    }
    return message;
  }

  internalBinaryWrite(
    message: Error,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* int32 error_code = 2; */
    if (message.errorCode !== 0) {
      writer.tag(2, WireType.Varint).int32(message.errorCode);
    }
    const u = options.writeUnknownFields;
    if (u !== false) {
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    }
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message kachaka_api.Error
 */
export const Error = new Error$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RosHeader$Type extends MessageType<RosHeader> {
  constructor() {
    super('kachaka_api.RosHeader', [
      {
        no: 1,
        name: 'stamp_nsec',
        kind: 'scalar',
        T: 3 /* ScalarType.INT64 */,
        L: 0 /* LongType.BIGINT */,
      },
      { no: 2, name: 'frame_id', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    ]);
  }

  create(value?: PartialMessage<RosHeader>): RosHeader {
    const message = { stampNsec: 0n, frameId: '' };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined) {
      reflectionMergePartial<RosHeader>(this, message, value);
    }
    return message;
  }

  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: RosHeader,
  ): RosHeader {
    const message = target ?? this.create();
    const end = reader.pos + length;
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* int64 stamp_nsec */ 1:
          message.stampNsec = reader.int64().toBigInt();
          break;
        case /* string frame_id */ 2:
          message.frameId = reader.string();
          break;
        default:
          const u = options.readUnknownField;
          if (u === 'throw') {
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          }
          const d = reader.skip(wireType);
          if (u !== false) {
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
          }
      }
    }
    return message;
  }

  internalBinaryWrite(
    message: RosHeader,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* int64 stamp_nsec = 1; */
    if (message.stampNsec !== 0n) {
      writer.tag(1, WireType.Varint).int64(message.stampNsec);
    }
    /* string frame_id = 2; */
    if (message.frameId !== '') {
      writer.tag(2, WireType.LengthDelimited).string(message.frameId);
    }
    const u = options.writeUnknownFields;
    if (u !== false) {
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    }
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message kachaka_api.RosHeader
 */
export const RosHeader = new RosHeader$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Pose$Type extends MessageType<Pose> {
  constructor() {
    super('kachaka_api.Pose', [
      { no: 1, name: 'x', kind: 'scalar', T: 1 /* ScalarType.DOUBLE */ },
      { no: 2, name: 'y', kind: 'scalar', T: 1 /* ScalarType.DOUBLE */ },
      { no: 3, name: 'theta', kind: 'scalar', T: 1 /* ScalarType.DOUBLE */ },
    ]);
  }

  create(value?: PartialMessage<Pose>): Pose {
    const message = { x: 0, y: 0, theta: 0 };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined) {
      reflectionMergePartial<Pose>(this, message, value);
    }
    return message;
  }

  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: Pose,
  ): Pose {
    const message = target ?? this.create();
    const end = reader.pos + length;
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* double x */ 1:
          message.x = reader.double();
          break;
        case /* double y */ 2:
          message.y = reader.double();
          break;
        case /* double theta */ 3:
          message.theta = reader.double();
          break;
        default:
          const u = options.readUnknownField;
          if (u === 'throw') {
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          }
          const d = reader.skip(wireType);
          if (u !== false) {
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
          }
      }
    }
    return message;
  }

  internalBinaryWrite(
    message: Pose,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* double x = 1; */
    if (message.x !== 0) {
      writer.tag(1, WireType.Bit64).double(message.x);
    }
    /* double y = 2; */
    if (message.y !== 0) {
      writer.tag(2, WireType.Bit64).double(message.y);
    }
    /* double theta = 3; */
    if (message.theta !== 0) {
      writer.tag(3, WireType.Bit64).double(message.theta);
    }
    const u = options.writeUnknownFields;
    if (u !== false) {
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    }
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message kachaka_api.Pose
 */
export const Pose = new Pose$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Vector3$Type extends MessageType<Vector3> {
  constructor() {
    super('kachaka_api.Vector3', [
      { no: 1, name: 'x', kind: 'scalar', T: 1 /* ScalarType.DOUBLE */ },
      { no: 2, name: 'y', kind: 'scalar', T: 1 /* ScalarType.DOUBLE */ },
      { no: 3, name: 'z', kind: 'scalar', T: 1 /* ScalarType.DOUBLE */ },
    ]);
  }

  create(value?: PartialMessage<Vector3>): Vector3 {
    const message = { x: 0, y: 0, z: 0 };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined) {
      reflectionMergePartial<Vector3>(this, message, value);
    }
    return message;
  }

  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: Vector3,
  ): Vector3 {
    const message = target ?? this.create();
    const end = reader.pos + length;
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* double x */ 1:
          message.x = reader.double();
          break;
        case /* double y */ 2:
          message.y = reader.double();
          break;
        case /* double z */ 3:
          message.z = reader.double();
          break;
        default:
          const u = options.readUnknownField;
          if (u === 'throw') {
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          }
          const d = reader.skip(wireType);
          if (u !== false) {
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
          }
      }
    }
    return message;
  }

  internalBinaryWrite(
    message: Vector3,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* double x = 1; */
    if (message.x !== 0) {
      writer.tag(1, WireType.Bit64).double(message.x);
    }
    /* double y = 2; */
    if (message.y !== 0) {
      writer.tag(2, WireType.Bit64).double(message.y);
    }
    /* double z = 3; */
    if (message.z !== 0) {
      writer.tag(3, WireType.Bit64).double(message.z);
    }
    const u = options.writeUnknownFields;
    if (u !== false) {
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    }
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message kachaka_api.Vector3
 */
export const Vector3 = new Vector3$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Quaternion$Type extends MessageType<Quaternion> {
  constructor() {
    super('kachaka_api.Quaternion', [
      { no: 1, name: 'x', kind: 'scalar', T: 1 /* ScalarType.DOUBLE */ },
      { no: 2, name: 'y', kind: 'scalar', T: 1 /* ScalarType.DOUBLE */ },
      { no: 3, name: 'z', kind: 'scalar', T: 1 /* ScalarType.DOUBLE */ },
      { no: 4, name: 'w', kind: 'scalar', T: 1 /* ScalarType.DOUBLE */ },
    ]);
  }

  create(value?: PartialMessage<Quaternion>): Quaternion {
    const message = { x: 0, y: 0, z: 0, w: 0 };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined) {
      reflectionMergePartial<Quaternion>(this, message, value);
    }
    return message;
  }

  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: Quaternion,
  ): Quaternion {
    const message = target ?? this.create();
    const end = reader.pos + length;
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* double x */ 1:
          message.x = reader.double();
          break;
        case /* double y */ 2:
          message.y = reader.double();
          break;
        case /* double z */ 3:
          message.z = reader.double();
          break;
        case /* double w */ 4:
          message.w = reader.double();
          break;
        default:
          const u = options.readUnknownField;
          if (u === 'throw') {
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          }
          const d = reader.skip(wireType);
          if (u !== false) {
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
          }
      }
    }
    return message;
  }

  internalBinaryWrite(
    message: Quaternion,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* double x = 1; */
    if (message.x !== 0) {
      writer.tag(1, WireType.Bit64).double(message.x);
    }
    /* double y = 2; */
    if (message.y !== 0) {
      writer.tag(2, WireType.Bit64).double(message.y);
    }
    /* double z = 3; */
    if (message.z !== 0) {
      writer.tag(3, WireType.Bit64).double(message.z);
    }
    /* double w = 4; */
    if (message.w !== 0) {
      writer.tag(4, WireType.Bit64).double(message.w);
    }
    const u = options.writeUnknownFields;
    if (u !== false) {
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    }
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message kachaka_api.Quaternion
 */
export const Quaternion = new Quaternion$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Pose3d$Type extends MessageType<Pose3d> {
  constructor() {
    super('kachaka_api.Pose3d', [
      { no: 1, name: 'position', kind: 'message', T: () => Vector3 },
      { no: 2, name: 'orientation', kind: 'message', T: () => Quaternion },
    ]);
  }

  create(value?: PartialMessage<Pose3d>): Pose3d {
    const message = {};
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined) {
      reflectionMergePartial<Pose3d>(this, message, value);
    }
    return message;
  }

  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: Pose3d,
  ): Pose3d {
    const message = target ?? this.create();
    const end = reader.pos + length;
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* kachaka_api.Vector3 position */ 1:
          message.position = Vector3.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.position,
          );
          break;
        case /* kachaka_api.Quaternion orientation */ 2:
          message.orientation = Quaternion.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.orientation,
          );
          break;
        default:
          const u = options.readUnknownField;
          if (u === 'throw') {
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          }
          const d = reader.skip(wireType);
          if (u !== false) {
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
          }
      }
    }
    return message;
  }

  internalBinaryWrite(
    message: Pose3d,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* kachaka_api.Vector3 position = 1; */
    if (message.position) {
      Vector3.internalBinaryWrite(
        message.position,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    }
    /* kachaka_api.Quaternion orientation = 2; */
    if (message.orientation) {
      Quaternion.internalBinaryWrite(
        message.orientation,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    }
    const u = options.writeUnknownFields;
    if (u !== false) {
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    }
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message kachaka_api.Pose3d
 */
export const Pose3d = new Pose3d$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Twist$Type extends MessageType<Twist> {
  constructor() {
    super('kachaka_api.Twist', [
      { no: 1, name: 'linear', kind: 'message', T: () => Vector3 },
      { no: 2, name: 'angular', kind: 'message', T: () => Vector3 },
    ]);
  }

  create(value?: PartialMessage<Twist>): Twist {
    const message = {};
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined) {
      reflectionMergePartial<Twist>(this, message, value);
    }
    return message;
  }

  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: Twist,
  ): Twist {
    const message = target ?? this.create();
    const end = reader.pos + length;
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* kachaka_api.Vector3 linear */ 1:
          message.linear = Vector3.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.linear,
          );
          break;
        case /* kachaka_api.Vector3 angular */ 2:
          message.angular = Vector3.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.angular,
          );
          break;
        default:
          const u = options.readUnknownField;
          if (u === 'throw') {
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          }
          const d = reader.skip(wireType);
          if (u !== false) {
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
          }
      }
    }
    return message;
  }

  internalBinaryWrite(
    message: Twist,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* kachaka_api.Vector3 linear = 1; */
    if (message.linear) {
      Vector3.internalBinaryWrite(
        message.linear,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    }
    /* kachaka_api.Vector3 angular = 2; */
    if (message.angular) {
      Vector3.internalBinaryWrite(
        message.angular,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    }
    const u = options.writeUnknownFields;
    if (u !== false) {
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    }
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message kachaka_api.Twist
 */
export const Twist = new Twist$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Pose3dWithCovariance$Type extends MessageType<Pose3dWithCovariance> {
  constructor() {
    super('kachaka_api.Pose3dWithCovariance', [
      { no: 1, name: 'pose', kind: 'message', T: () => Pose3d },
      {
        no: 2,
        name: 'covariance',
        kind: 'scalar',
        repeat: 1 /* RepeatType.PACKED */,
        T: 1 /* ScalarType.DOUBLE */,
      },
    ]);
  }

  create(value?: PartialMessage<Pose3dWithCovariance>): Pose3dWithCovariance {
    const message = { covariance: [] };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined) {
      reflectionMergePartial<Pose3dWithCovariance>(this, message, value);
    }
    return message;
  }

  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: Pose3dWithCovariance,
  ): Pose3dWithCovariance {
    const message = target ?? this.create();
    const end = reader.pos + length;
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* kachaka_api.Pose3d pose */ 1:
          message.pose = Pose3d.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.pose,
          );
          break;
        case /* repeated double covariance */ 2:
          if (wireType === WireType.LengthDelimited) {
            for (let e = reader.int32() + reader.pos; reader.pos < e; ) {
              message.covariance.push(reader.double());
            }
          } else {
            message.covariance.push(reader.double());
          }
          break;
        default:
          const u = options.readUnknownField;
          if (u === 'throw') {
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          }
          const d = reader.skip(wireType);
          if (u !== false) {
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
          }
      }
    }
    return message;
  }

  internalBinaryWrite(
    message: Pose3dWithCovariance,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* kachaka_api.Pose3d pose = 1; */
    if (message.pose) {
      Pose3d.internalBinaryWrite(
        message.pose,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    }
    /* repeated double covariance = 2; */
    if (message.covariance.length > 0) {
      writer.tag(2, WireType.LengthDelimited).fork();
      for (let i = 0; i < message.covariance.length; i++) {
        writer.double(message.covariance[i]);
      }
      writer.join();
    }
    const u = options.writeUnknownFields;
    if (u !== false) {
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    }
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message kachaka_api.Pose3dWithCovariance
 */
export const Pose3dWithCovariance = new Pose3dWithCovariance$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TwistWithCovariance$Type extends MessageType<TwistWithCovariance> {
  constructor() {
    super('kachaka_api.TwistWithCovariance', [
      { no: 1, name: 'twist', kind: 'message', T: () => Twist },
      {
        no: 2,
        name: 'covariance',
        kind: 'scalar',
        repeat: 1 /* RepeatType.PACKED */,
        T: 1 /* ScalarType.DOUBLE */,
      },
    ]);
  }

  create(value?: PartialMessage<TwistWithCovariance>): TwistWithCovariance {
    const message = { covariance: [] };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined) {
      reflectionMergePartial<TwistWithCovariance>(this, message, value);
    }
    return message;
  }

  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: TwistWithCovariance,
  ): TwistWithCovariance {
    const message = target ?? this.create();
    const end = reader.pos + length;
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* kachaka_api.Twist twist */ 1:
          message.twist = Twist.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.twist,
          );
          break;
        case /* repeated double covariance */ 2:
          if (wireType === WireType.LengthDelimited) {
            for (let e = reader.int32() + reader.pos; reader.pos < e; ) {
              message.covariance.push(reader.double());
            }
          } else {
            message.covariance.push(reader.double());
          }
          break;
        default:
          const u = options.readUnknownField;
          if (u === 'throw') {
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          }
          const d = reader.skip(wireType);
          if (u !== false) {
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
          }
      }
    }
    return message;
  }

  internalBinaryWrite(
    message: TwistWithCovariance,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* kachaka_api.Twist twist = 1; */
    if (message.twist) {
      Twist.internalBinaryWrite(
        message.twist,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    }
    /* repeated double covariance = 2; */
    if (message.covariance.length > 0) {
      writer.tag(2, WireType.LengthDelimited).fork();
      for (let i = 0; i < message.covariance.length; i++) {
        writer.double(message.covariance[i]);
      }
      writer.join();
    }
    const u = options.writeUnknownFields;
    if (u !== false) {
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    }
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message kachaka_api.TwistWithCovariance
 */
export const TwistWithCovariance = new TwistWithCovariance$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Map$Type extends MessageType<Map> {
  constructor() {
    super('kachaka_api.Map', [
      { no: 1, name: 'data', kind: 'scalar', T: 12 /* ScalarType.BYTES */ },
      { no: 2, name: 'name', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
      {
        no: 3,
        name: 'resolution',
        kind: 'scalar',
        T: 1 /* ScalarType.DOUBLE */,
      },
      { no: 4, name: 'width', kind: 'scalar', T: 5 /* ScalarType.INT32 */ },
      { no: 5, name: 'height', kind: 'scalar', T: 5 /* ScalarType.INT32 */ },
      { no: 6, name: 'origin', kind: 'message', T: () => Pose },
    ]);
  }

  create(value?: PartialMessage<Map>): Map {
    const message = {
      data: new Uint8Array(0),
      name: '',
      resolution: 0,
      width: 0,
      height: 0,
    };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined) {
      reflectionMergePartial<Map>(this, message, value);
    }
    return message;
  }

  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: Map,
  ): Map {
    const message = target ?? this.create();
    const end = reader.pos + length;
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes data */ 1:
          message.data = reader.bytes();
          break;
        case /* string name */ 2:
          message.name = reader.string();
          break;
        case /* double resolution */ 3:
          message.resolution = reader.double();
          break;
        case /* int32 width */ 4:
          message.width = reader.int32();
          break;
        case /* int32 height */ 5:
          message.height = reader.int32();
          break;
        case /* kachaka_api.Pose origin */ 6:
          message.origin = Pose.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.origin,
          );
          break;
        default:
          const u = options.readUnknownField;
          if (u === 'throw') {
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          }
          const d = reader.skip(wireType);
          if (u !== false) {
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
          }
      }
    }
    return message;
  }

  internalBinaryWrite(
    message: Map,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* bytes data = 1; */
    if (message.data.length) {
      writer.tag(1, WireType.LengthDelimited).bytes(message.data);
    }
    /* string name = 2; */
    if (message.name !== '') {
      writer.tag(2, WireType.LengthDelimited).string(message.name);
    }
    /* double resolution = 3; */
    if (message.resolution !== 0) {
      writer.tag(3, WireType.Bit64).double(message.resolution);
    }
    /* int32 width = 4; */
    if (message.width !== 0) {
      writer.tag(4, WireType.Varint).int32(message.width);
    }
    /* int32 height = 5; */
    if (message.height !== 0) {
      writer.tag(5, WireType.Varint).int32(message.height);
    }
    /* kachaka_api.Pose origin = 6; */
    if (message.origin) {
      Pose.internalBinaryWrite(
        message.origin,
        writer.tag(6, WireType.LengthDelimited).fork(),
        options,
      ).join();
    }
    const u = options.writeUnknownFields;
    if (u !== false) {
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    }
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message kachaka_api.Map
 */
export const Map = new Map$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Location$Type extends MessageType<Location> {
  constructor() {
    super('kachaka_api.Location', [
      { no: 1, name: 'id', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
      { no: 2, name: 'name', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
      { no: 3, name: 'pose', kind: 'message', T: () => Pose },
      {
        no: 4,
        name: 'type',
        kind: 'enum',
        T: () => ['kachaka_api.LocationType', LocationType, 'LOCATION_TYPE_'],
      },
      {
        no: 5,
        name: 'undock_shelf_aligning_to_wall',
        kind: 'scalar',
        T: 8 /* ScalarType.BOOL */,
      },
      {
        no: 6,
        name: 'undock_shelf_avoiding_obstacles',
        kind: 'scalar',
        T: 8 /* ScalarType.BOOL */,
      },
      {
        no: 7,
        name: 'ignore_voice_recognition',
        kind: 'scalar',
        T: 8 /* ScalarType.BOOL */,
      },
    ]);
  }

  create(value?: PartialMessage<Location>): Location {
    const message = {
      id: '',
      name: '',
      type: 0,
      undockShelfAligningToWall: false,
      undockShelfAvoidingObstacles: false,
      ignoreVoiceRecognition: false,
    };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined) {
      reflectionMergePartial<Location>(this, message, value);
    }
    return message;
  }

  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: Location,
  ): Location {
    const message = target ?? this.create();
    const end = reader.pos + length;
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string id */ 1:
          message.id = reader.string();
          break;
        case /* string name */ 2:
          message.name = reader.string();
          break;
        case /* kachaka_api.Pose pose */ 3:
          message.pose = Pose.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.pose,
          );
          break;
        case /* kachaka_api.LocationType type */ 4:
          message.type = reader.int32();
          break;
        case /* bool undock_shelf_aligning_to_wall */ 5:
          message.undockShelfAligningToWall = reader.bool();
          break;
        case /* bool undock_shelf_avoiding_obstacles */ 6:
          message.undockShelfAvoidingObstacles = reader.bool();
          break;
        case /* bool ignore_voice_recognition */ 7:
          message.ignoreVoiceRecognition = reader.bool();
          break;
        default:
          const u = options.readUnknownField;
          if (u === 'throw') {
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          }
          const d = reader.skip(wireType);
          if (u !== false) {
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
          }
      }
    }
    return message;
  }

  internalBinaryWrite(
    message: Location,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string id = 1; */
    if (message.id !== '') {
      writer.tag(1, WireType.LengthDelimited).string(message.id);
    }
    /* string name = 2; */
    if (message.name !== '') {
      writer.tag(2, WireType.LengthDelimited).string(message.name);
    }
    /* kachaka_api.Pose pose = 3; */
    if (message.pose) {
      Pose.internalBinaryWrite(
        message.pose,
        writer.tag(3, WireType.LengthDelimited).fork(),
        options,
      ).join();
    }
    /* kachaka_api.LocationType type = 4; */
    if (message.type !== 0) {
      writer.tag(4, WireType.Varint).int32(message.type);
    }
    /* bool undock_shelf_aligning_to_wall = 5; */
    if (message.undockShelfAligningToWall) {
      writer.tag(5, WireType.Varint).bool(message.undockShelfAligningToWall);
    }
    /* bool undock_shelf_avoiding_obstacles = 6; */
    if (message.undockShelfAvoidingObstacles) {
      writer.tag(6, WireType.Varint).bool(message.undockShelfAvoidingObstacles);
    }
    /* bool ignore_voice_recognition = 7; */
    if (message.ignoreVoiceRecognition) {
      writer.tag(7, WireType.Varint).bool(message.ignoreVoiceRecognition);
    }
    const u = options.writeUnknownFields;
    if (u !== false) {
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    }
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message kachaka_api.Location
 */
export const Location = new Location$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ShelfSize$Type extends MessageType<ShelfSize> {
  constructor() {
    super('kachaka_api.ShelfSize', [
      { no: 1, name: 'width', kind: 'scalar', T: 1 /* ScalarType.DOUBLE */ },
      { no: 2, name: 'depth', kind: 'scalar', T: 1 /* ScalarType.DOUBLE */ },
      { no: 3, name: 'height', kind: 'scalar', T: 1 /* ScalarType.DOUBLE */ },
    ]);
  }

  create(value?: PartialMessage<ShelfSize>): ShelfSize {
    const message = { width: 0, depth: 0, height: 0 };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined) {
      reflectionMergePartial<ShelfSize>(this, message, value);
    }
    return message;
  }

  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ShelfSize,
  ): ShelfSize {
    const message = target ?? this.create();
    const end = reader.pos + length;
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* double width */ 1:
          message.width = reader.double();
          break;
        case /* double depth */ 2:
          message.depth = reader.double();
          break;
        case /* double height */ 3:
          message.height = reader.double();
          break;
        default:
          const u = options.readUnknownField;
          if (u === 'throw') {
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          }
          const d = reader.skip(wireType);
          if (u !== false) {
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
          }
      }
    }
    return message;
  }

  internalBinaryWrite(
    message: ShelfSize,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* double width = 1; */
    if (message.width !== 0) {
      writer.tag(1, WireType.Bit64).double(message.width);
    }
    /* double depth = 2; */
    if (message.depth !== 0) {
      writer.tag(2, WireType.Bit64).double(message.depth);
    }
    /* double height = 3; */
    if (message.height !== 0) {
      writer.tag(3, WireType.Bit64).double(message.height);
    }
    const u = options.writeUnknownFields;
    if (u !== false) {
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    }
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message kachaka_api.ShelfSize
 */
export const ShelfSize = new ShelfSize$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RecognizableName$Type extends MessageType<RecognizableName> {
  constructor() {
    super('kachaka_api.RecognizableName', [
      { no: 1, name: 'name', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
      { no: 2, name: 'deletable', kind: 'scalar', T: 8 /* ScalarType.BOOL */ },
    ]);
  }

  create(value?: PartialMessage<RecognizableName>): RecognizableName {
    const message = { name: '', deletable: false };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined) {
      reflectionMergePartial<RecognizableName>(this, message, value);
    }
    return message;
  }

  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: RecognizableName,
  ): RecognizableName {
    const message = target ?? this.create();
    const end = reader.pos + length;
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string name */ 1:
          message.name = reader.string();
          break;
        case /* bool deletable */ 2:
          message.deletable = reader.bool();
          break;
        default:
          const u = options.readUnknownField;
          if (u === 'throw') {
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          }
          const d = reader.skip(wireType);
          if (u !== false) {
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
          }
      }
    }
    return message;
  }

  internalBinaryWrite(
    message: RecognizableName,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string name = 1; */
    if (message.name !== '') {
      writer.tag(1, WireType.LengthDelimited).string(message.name);
    }
    /* bool deletable = 2; */
    if (message.deletable) {
      writer.tag(2, WireType.Varint).bool(message.deletable);
    }
    const u = options.writeUnknownFields;
    if (u !== false) {
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    }
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message kachaka_api.RecognizableName
 */
export const RecognizableName = new RecognizableName$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Shelf$Type extends MessageType<Shelf> {
  constructor() {
    super('kachaka_api.Shelf', [
      { no: 1, name: 'id', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
      { no: 2, name: 'name', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
      { no: 3, name: 'pose', kind: 'message', T: () => Pose },
      { no: 4, name: 'size', kind: 'message', T: () => ShelfSize },
      {
        no: 5,
        name: 'appearance',
        kind: 'enum',
        T: () => [
          'kachaka_api.ShelfAppearance',
          ShelfAppearance,
          'SHELF_APPEARANCE_',
        ],
      },
      {
        no: 7,
        name: 'recognizable_names',
        kind: 'message',
        repeat: 1 /* RepeatType.PACKED */,
        T: () => RecognizableName,
      },
      {
        no: 8,
        name: 'home_location_id',
        kind: 'scalar',
        T: 9 /* ScalarType.STRING */,
      },
      {
        no: 9,
        name: 'speed_mode',
        kind: 'enum',
        T: () => [
          'kachaka_api.ShelfSpeedMode',
          ShelfSpeedMode,
          'SHELF_SPEED_MODE_',
        ],
      },
      {
        no: 10,
        name: 'ignore_voice_recognition',
        kind: 'scalar',
        T: 8 /* ScalarType.BOOL */,
      },
    ]);
  }

  create(value?: PartialMessage<Shelf>): Shelf {
    const message = {
      id: '',
      name: '',
      appearance: 0,
      recognizableNames: [],
      homeLocationId: '',
      speedMode: 0,
      ignoreVoiceRecognition: false,
    };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined) {
      reflectionMergePartial<Shelf>(this, message, value);
    }
    return message;
  }

  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: Shelf,
  ): Shelf {
    const message = target ?? this.create();
    const end = reader.pos + length;
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string id */ 1:
          message.id = reader.string();
          break;
        case /* string name */ 2:
          message.name = reader.string();
          break;
        case /* kachaka_api.Pose pose */ 3:
          message.pose = Pose.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.pose,
          );
          break;
        case /* kachaka_api.ShelfSize size */ 4:
          message.size = ShelfSize.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.size,
          );
          break;
        case /* kachaka_api.ShelfAppearance appearance */ 5:
          message.appearance = reader.int32();
          break;
        case /* repeated kachaka_api.RecognizableName recognizable_names */ 7:
          message.recognizableNames.push(
            RecognizableName.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
            ),
          );
          break;
        case /* string home_location_id */ 8:
          message.homeLocationId = reader.string();
          break;
        case /* kachaka_api.ShelfSpeedMode speed_mode */ 9:
          message.speedMode = reader.int32();
          break;
        case /* bool ignore_voice_recognition */ 10:
          message.ignoreVoiceRecognition = reader.bool();
          break;
        default:
          const u = options.readUnknownField;
          if (u === 'throw') {
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          }
          const d = reader.skip(wireType);
          if (u !== false) {
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
          }
      }
    }
    return message;
  }

  internalBinaryWrite(
    message: Shelf,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string id = 1; */
    if (message.id !== '') {
      writer.tag(1, WireType.LengthDelimited).string(message.id);
    }
    /* string name = 2; */
    if (message.name !== '') {
      writer.tag(2, WireType.LengthDelimited).string(message.name);
    }
    /* kachaka_api.Pose pose = 3; */
    if (message.pose) {
      Pose.internalBinaryWrite(
        message.pose,
        writer.tag(3, WireType.LengthDelimited).fork(),
        options,
      ).join();
    }
    /* kachaka_api.ShelfSize size = 4; */
    if (message.size) {
      ShelfSize.internalBinaryWrite(
        message.size,
        writer.tag(4, WireType.LengthDelimited).fork(),
        options,
      ).join();
    }
    /* kachaka_api.ShelfAppearance appearance = 5; */
    if (message.appearance !== 0) {
      writer.tag(5, WireType.Varint).int32(message.appearance);
    }
    /* repeated kachaka_api.RecognizableName recognizable_names = 7; */
    for (let i = 0; i < message.recognizableNames.length; i++) {
      RecognizableName.internalBinaryWrite(
        message.recognizableNames[i],
        writer.tag(7, WireType.LengthDelimited).fork(),
        options,
      ).join();
    }
    /* string home_location_id = 8; */
    if (message.homeLocationId !== '') {
      writer.tag(8, WireType.LengthDelimited).string(message.homeLocationId);
    }
    /* kachaka_api.ShelfSpeedMode speed_mode = 9; */
    if (message.speedMode !== 0) {
      writer.tag(9, WireType.Varint).int32(message.speedMode);
    }
    /* bool ignore_voice_recognition = 10; */
    if (message.ignoreVoiceRecognition) {
      writer.tag(10, WireType.Varint).bool(message.ignoreVoiceRecognition);
    }
    const u = options.writeUnknownFields;
    if (u !== false) {
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    }
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message kachaka_api.Shelf
 */
export const Shelf = new Shelf$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RosImu$Type extends MessageType<RosImu> {
  constructor() {
    super('kachaka_api.RosImu', [
      { no: 1, name: 'header', kind: 'message', T: () => RosHeader },
      { no: 2, name: 'orientation', kind: 'message', T: () => Quaternion },
      {
        no: 3,
        name: 'orientation_covariance',
        kind: 'scalar',
        repeat: 1 /* RepeatType.PACKED */,
        T: 1 /* ScalarType.DOUBLE */,
      },
      { no: 4, name: 'angular_velocity', kind: 'message', T: () => Vector3 },
      {
        no: 5,
        name: 'angular_velocity_covariance',
        kind: 'scalar',
        repeat: 1 /* RepeatType.PACKED */,
        T: 1 /* ScalarType.DOUBLE */,
      },
      { no: 6, name: 'linear_acceleration', kind: 'message', T: () => Vector3 },
      {
        no: 7,
        name: 'linear_acceleration_covariance',
        kind: 'scalar',
        repeat: 1 /* RepeatType.PACKED */,
        T: 1 /* ScalarType.DOUBLE */,
      },
    ]);
  }

  create(value?: PartialMessage<RosImu>): RosImu {
    const message = {
      orientationCovariance: [],
      angularVelocityCovariance: [],
      linearAccelerationCovariance: [],
    };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined) {
      reflectionMergePartial<RosImu>(this, message, value);
    }
    return message;
  }

  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: RosImu,
  ): RosImu {
    const message = target ?? this.create();
    const end = reader.pos + length;
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* kachaka_api.RosHeader header */ 1:
          message.header = RosHeader.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.header,
          );
          break;
        case /* kachaka_api.Quaternion orientation */ 2:
          message.orientation = Quaternion.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.orientation,
          );
          break;
        case /* repeated double orientation_covariance */ 3:
          if (wireType === WireType.LengthDelimited) {
            for (let e = reader.int32() + reader.pos; reader.pos < e; ) {
              message.orientationCovariance.push(reader.double());
            }
          } else {
            message.orientationCovariance.push(reader.double());
          }
          break;
        case /* kachaka_api.Vector3 angular_velocity */ 4:
          message.angularVelocity = Vector3.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.angularVelocity,
          );
          break;
        case /* repeated double angular_velocity_covariance */ 5:
          if (wireType === WireType.LengthDelimited) {
            for (let e = reader.int32() + reader.pos; reader.pos < e; ) {
              message.angularVelocityCovariance.push(reader.double());
            }
          } else {
            message.angularVelocityCovariance.push(reader.double());
          }
          break;
        case /* kachaka_api.Vector3 linear_acceleration */ 6:
          message.linearAcceleration = Vector3.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.linearAcceleration,
          );
          break;
        case /* repeated double linear_acceleration_covariance */ 7:
          if (wireType === WireType.LengthDelimited) {
            for (let e = reader.int32() + reader.pos; reader.pos < e; ) {
              message.linearAccelerationCovariance.push(reader.double());
            }
          } else {
            message.linearAccelerationCovariance.push(reader.double());
          }
          break;
        default:
          const u = options.readUnknownField;
          if (u === 'throw') {
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          }
          const d = reader.skip(wireType);
          if (u !== false) {
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
          }
      }
    }
    return message;
  }

  internalBinaryWrite(
    message: RosImu,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* kachaka_api.RosHeader header = 1; */
    if (message.header) {
      RosHeader.internalBinaryWrite(
        message.header,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    }
    /* kachaka_api.Quaternion orientation = 2; */
    if (message.orientation) {
      Quaternion.internalBinaryWrite(
        message.orientation,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    }
    /* repeated double orientation_covariance = 3; */
    if (message.orientationCovariance.length > 0) {
      writer.tag(3, WireType.LengthDelimited).fork();
      for (let i = 0; i < message.orientationCovariance.length; i++) {
        writer.double(message.orientationCovariance[i]);
      }
      writer.join();
    }
    /* kachaka_api.Vector3 angular_velocity = 4; */
    if (message.angularVelocity) {
      Vector3.internalBinaryWrite(
        message.angularVelocity,
        writer.tag(4, WireType.LengthDelimited).fork(),
        options,
      ).join();
    }
    /* repeated double angular_velocity_covariance = 5; */
    if (message.angularVelocityCovariance.length > 0) {
      writer.tag(5, WireType.LengthDelimited).fork();
      for (let i = 0; i < message.angularVelocityCovariance.length; i++) {
        writer.double(message.angularVelocityCovariance[i]);
      }
      writer.join();
    }
    /* kachaka_api.Vector3 linear_acceleration = 6; */
    if (message.linearAcceleration) {
      Vector3.internalBinaryWrite(
        message.linearAcceleration,
        writer.tag(6, WireType.LengthDelimited).fork(),
        options,
      ).join();
    }
    /* repeated double linear_acceleration_covariance = 7; */
    if (message.linearAccelerationCovariance.length > 0) {
      writer.tag(7, WireType.LengthDelimited).fork();
      for (let i = 0; i < message.linearAccelerationCovariance.length; i++) {
        writer.double(message.linearAccelerationCovariance[i]);
      }
      writer.join();
    }
    const u = options.writeUnknownFields;
    if (u !== false) {
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    }
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message kachaka_api.RosImu
 */
export const RosImu = new RosImu$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RosOdometry$Type extends MessageType<RosOdometry> {
  constructor() {
    super('kachaka_api.RosOdometry', [
      { no: 1, name: 'header', kind: 'message', T: () => RosHeader },
      {
        no: 2,
        name: 'child_frame_id',
        kind: 'scalar',
        T: 9 /* ScalarType.STRING */,
      },
      { no: 3, name: 'pose', kind: 'message', T: () => Pose3dWithCovariance },
      { no: 4, name: 'twist', kind: 'message', T: () => TwistWithCovariance },
    ]);
  }

  create(value?: PartialMessage<RosOdometry>): RosOdometry {
    const message = { childFrameId: '' };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined) {
      reflectionMergePartial<RosOdometry>(this, message, value);
    }
    return message;
  }

  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: RosOdometry,
  ): RosOdometry {
    const message = target ?? this.create();
    const end = reader.pos + length;
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* kachaka_api.RosHeader header */ 1:
          message.header = RosHeader.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.header,
          );
          break;
        case /* string child_frame_id */ 2:
          message.childFrameId = reader.string();
          break;
        case /* kachaka_api.Pose3dWithCovariance pose */ 3:
          message.pose = Pose3dWithCovariance.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.pose,
          );
          break;
        case /* kachaka_api.TwistWithCovariance twist */ 4:
          message.twist = TwistWithCovariance.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.twist,
          );
          break;
        default:
          const u = options.readUnknownField;
          if (u === 'throw') {
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          }
          const d = reader.skip(wireType);
          if (u !== false) {
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
          }
      }
    }
    return message;
  }

  internalBinaryWrite(
    message: RosOdometry,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* kachaka_api.RosHeader header = 1; */
    if (message.header) {
      RosHeader.internalBinaryWrite(
        message.header,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    }
    /* string child_frame_id = 2; */
    if (message.childFrameId !== '') {
      writer.tag(2, WireType.LengthDelimited).string(message.childFrameId);
    }
    /* kachaka_api.Pose3dWithCovariance pose = 3; */
    if (message.pose) {
      Pose3dWithCovariance.internalBinaryWrite(
        message.pose,
        writer.tag(3, WireType.LengthDelimited).fork(),
        options,
      ).join();
    }
    /* kachaka_api.TwistWithCovariance twist = 4; */
    if (message.twist) {
      TwistWithCovariance.internalBinaryWrite(
        message.twist,
        writer.tag(4, WireType.LengthDelimited).fork(),
        options,
      ).join();
    }
    const u = options.writeUnknownFields;
    if (u !== false) {
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    }
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message kachaka_api.RosOdometry
 */
export const RosOdometry = new RosOdometry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RosLaserScan$Type extends MessageType<RosLaserScan> {
  constructor() {
    super('kachaka_api.RosLaserScan', [
      { no: 1, name: 'header', kind: 'message', T: () => RosHeader },
      {
        no: 2,
        name: 'angle_min',
        kind: 'scalar',
        T: 1 /* ScalarType.DOUBLE */,
      },
      {
        no: 3,
        name: 'angle_max',
        kind: 'scalar',
        T: 1 /* ScalarType.DOUBLE */,
      },
      {
        no: 4,
        name: 'angle_increment',
        kind: 'scalar',
        T: 1 /* ScalarType.DOUBLE */,
      },
      {
        no: 5,
        name: 'time_increment',
        kind: 'scalar',
        T: 1 /* ScalarType.DOUBLE */,
      },
      {
        no: 6,
        name: 'scan_time',
        kind: 'scalar',
        T: 1 /* ScalarType.DOUBLE */,
      },
      {
        no: 7,
        name: 'range_min',
        kind: 'scalar',
        T: 1 /* ScalarType.DOUBLE */,
      },
      {
        no: 8,
        name: 'range_max',
        kind: 'scalar',
        T: 1 /* ScalarType.DOUBLE */,
      },
      {
        no: 9,
        name: 'ranges',
        kind: 'scalar',
        repeat: 1 /* RepeatType.PACKED */,
        T: 1 /* ScalarType.DOUBLE */,
      },
      {
        no: 10,
        name: 'intensities',
        kind: 'scalar',
        repeat: 1 /* RepeatType.PACKED */,
        T: 1 /* ScalarType.DOUBLE */,
      },
    ]);
  }

  create(value?: PartialMessage<RosLaserScan>): RosLaserScan {
    const message = {
      angleMin: 0,
      angleMax: 0,
      angleIncrement: 0,
      timeIncrement: 0,
      scanTime: 0,
      rangeMin: 0,
      rangeMax: 0,
      ranges: [],
      intensities: [],
    };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined) {
      reflectionMergePartial<RosLaserScan>(this, message, value);
    }
    return message;
  }

  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: RosLaserScan,
  ): RosLaserScan {
    const message = target ?? this.create();
    const end = reader.pos + length;
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* kachaka_api.RosHeader header */ 1:
          message.header = RosHeader.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.header,
          );
          break;
        case /* double angle_min */ 2:
          message.angleMin = reader.double();
          break;
        case /* double angle_max */ 3:
          message.angleMax = reader.double();
          break;
        case /* double angle_increment */ 4:
          message.angleIncrement = reader.double();
          break;
        case /* double time_increment */ 5:
          message.timeIncrement = reader.double();
          break;
        case /* double scan_time */ 6:
          message.scanTime = reader.double();
          break;
        case /* double range_min */ 7:
          message.rangeMin = reader.double();
          break;
        case /* double range_max */ 8:
          message.rangeMax = reader.double();
          break;
        case /* repeated double ranges */ 9:
          if (wireType === WireType.LengthDelimited) {
            for (let e = reader.int32() + reader.pos; reader.pos < e; ) {
              message.ranges.push(reader.double());
            }
          } else {
            message.ranges.push(reader.double());
          }
          break;
        case /* repeated double intensities */ 10:
          if (wireType === WireType.LengthDelimited) {
            for (let e = reader.int32() + reader.pos; reader.pos < e; ) {
              message.intensities.push(reader.double());
            }
          } else {
            message.intensities.push(reader.double());
          }
          break;
        default:
          const u = options.readUnknownField;
          if (u === 'throw') {
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          }
          const d = reader.skip(wireType);
          if (u !== false) {
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
          }
      }
    }
    return message;
  }

  internalBinaryWrite(
    message: RosLaserScan,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* kachaka_api.RosHeader header = 1; */
    if (message.header) {
      RosHeader.internalBinaryWrite(
        message.header,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    }
    /* double angle_min = 2; */
    if (message.angleMin !== 0) {
      writer.tag(2, WireType.Bit64).double(message.angleMin);
    }
    /* double angle_max = 3; */
    if (message.angleMax !== 0) {
      writer.tag(3, WireType.Bit64).double(message.angleMax);
    }
    /* double angle_increment = 4; */
    if (message.angleIncrement !== 0) {
      writer.tag(4, WireType.Bit64).double(message.angleIncrement);
    }
    /* double time_increment = 5; */
    if (message.timeIncrement !== 0) {
      writer.tag(5, WireType.Bit64).double(message.timeIncrement);
    }
    /* double scan_time = 6; */
    if (message.scanTime !== 0) {
      writer.tag(6, WireType.Bit64).double(message.scanTime);
    }
    /* double range_min = 7; */
    if (message.rangeMin !== 0) {
      writer.tag(7, WireType.Bit64).double(message.rangeMin);
    }
    /* double range_max = 8; */
    if (message.rangeMax !== 0) {
      writer.tag(8, WireType.Bit64).double(message.rangeMax);
    }
    /* repeated double ranges = 9; */
    if (message.ranges.length > 0) {
      writer.tag(9, WireType.LengthDelimited).fork();
      for (let i = 0; i < message.ranges.length; i++) {
        writer.double(message.ranges[i]);
      }
      writer.join();
    }
    /* repeated double intensities = 10; */
    if (message.intensities.length > 0) {
      writer.tag(10, WireType.LengthDelimited).fork();
      for (let i = 0; i < message.intensities.length; i++) {
        writer.double(message.intensities[i]);
      }
      writer.join();
    }
    const u = options.writeUnknownFields;
    if (u !== false) {
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    }
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message kachaka_api.RosLaserScan
 */
export const RosLaserScan = new RosLaserScan$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RegionOfInterest$Type extends MessageType<RegionOfInterest> {
  constructor() {
    super('kachaka_api.RegionOfInterest', [
      {
        no: 1,
        name: 'x_offset',
        kind: 'scalar',
        T: 13 /* ScalarType.UINT32 */,
      },
      {
        no: 2,
        name: 'y_offset',
        kind: 'scalar',
        T: 13 /* ScalarType.UINT32 */,
      },
      { no: 3, name: 'height', kind: 'scalar', T: 13 /* ScalarType.UINT32 */ },
      { no: 4, name: 'width', kind: 'scalar', T: 13 /* ScalarType.UINT32 */ },
      { no: 5, name: 'do_rectify', kind: 'scalar', T: 8 /* ScalarType.BOOL */ },
    ]);
  }

  create(value?: PartialMessage<RegionOfInterest>): RegionOfInterest {
    const message = {
      xOffset: 0,
      yOffset: 0,
      height: 0,
      width: 0,
      doRectify: false,
    };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined) {
      reflectionMergePartial<RegionOfInterest>(this, message, value);
    }
    return message;
  }

  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: RegionOfInterest,
  ): RegionOfInterest {
    const message = target ?? this.create();
    const end = reader.pos + length;
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* uint32 x_offset */ 1:
          message.xOffset = reader.uint32();
          break;
        case /* uint32 y_offset */ 2:
          message.yOffset = reader.uint32();
          break;
        case /* uint32 height */ 3:
          message.height = reader.uint32();
          break;
        case /* uint32 width */ 4:
          message.width = reader.uint32();
          break;
        case /* bool do_rectify */ 5:
          message.doRectify = reader.bool();
          break;
        default:
          const u = options.readUnknownField;
          if (u === 'throw') {
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          }
          const d = reader.skip(wireType);
          if (u !== false) {
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
          }
      }
    }
    return message;
  }

  internalBinaryWrite(
    message: RegionOfInterest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* uint32 x_offset = 1; */
    if (message.xOffset !== 0) {
      writer.tag(1, WireType.Varint).uint32(message.xOffset);
    }
    /* uint32 y_offset = 2; */
    if (message.yOffset !== 0) {
      writer.tag(2, WireType.Varint).uint32(message.yOffset);
    }
    /* uint32 height = 3; */
    if (message.height !== 0) {
      writer.tag(3, WireType.Varint).uint32(message.height);
    }
    /* uint32 width = 4; */
    if (message.width !== 0) {
      writer.tag(4, WireType.Varint).uint32(message.width);
    }
    /* bool do_rectify = 5; */
    if (message.doRectify) {
      writer.tag(5, WireType.Varint).bool(message.doRectify);
    }
    const u = options.writeUnknownFields;
    if (u !== false) {
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    }
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message kachaka_api.RegionOfInterest
 */
export const RegionOfInterest = new RegionOfInterest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RosCameraInfo$Type extends MessageType<RosCameraInfo> {
  constructor() {
    super('kachaka_api.RosCameraInfo', [
      { no: 1, name: 'header', kind: 'message', T: () => RosHeader },
      { no: 2, name: 'height', kind: 'scalar', T: 13 /* ScalarType.UINT32 */ },
      { no: 3, name: 'width', kind: 'scalar', T: 13 /* ScalarType.UINT32 */ },
      {
        no: 4,
        name: 'distortion_model',
        kind: 'scalar',
        T: 9 /* ScalarType.STRING */,
      },
      {
        no: 5,
        name: 'D',
        kind: 'scalar',
        jsonName: 'D',
        repeat: 1 /* RepeatType.PACKED */,
        T: 1 /* ScalarType.DOUBLE */,
      },
      {
        no: 6,
        name: 'K',
        kind: 'scalar',
        jsonName: 'K',
        repeat: 1 /* RepeatType.PACKED */,
        T: 1 /* ScalarType.DOUBLE */,
      },
      {
        no: 7,
        name: 'R',
        kind: 'scalar',
        jsonName: 'R',
        repeat: 1 /* RepeatType.PACKED */,
        T: 1 /* ScalarType.DOUBLE */,
      },
      {
        no: 8,
        name: 'P',
        kind: 'scalar',
        jsonName: 'P',
        repeat: 1 /* RepeatType.PACKED */,
        T: 1 /* ScalarType.DOUBLE */,
      },
      {
        no: 9,
        name: 'binning_x',
        kind: 'scalar',
        T: 13 /* ScalarType.UINT32 */,
      },
      {
        no: 10,
        name: 'binning_y',
        kind: 'scalar',
        T: 13 /* ScalarType.UINT32 */,
      },
      { no: 11, name: 'roi', kind: 'message', T: () => RegionOfInterest },
    ]);
  }

  create(value?: PartialMessage<RosCameraInfo>): RosCameraInfo {
    const message = {
      height: 0,
      width: 0,
      distortionModel: '',
      d: [],
      k: [],
      r: [],
      p: [],
      binningX: 0,
      binningY: 0,
    };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined) {
      reflectionMergePartial<RosCameraInfo>(this, message, value);
    }
    return message;
  }

  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: RosCameraInfo,
  ): RosCameraInfo {
    const message = target ?? this.create();
    const end = reader.pos + length;
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* kachaka_api.RosHeader header */ 1:
          message.header = RosHeader.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.header,
          );
          break;
        case /* uint32 height */ 2:
          message.height = reader.uint32();
          break;
        case /* uint32 width */ 3:
          message.width = reader.uint32();
          break;
        case /* string distortion_model */ 4:
          message.distortionModel = reader.string();
          break;
        case /* repeated double D = 5 [json_name = "D"]; */ 5:
          if (wireType === WireType.LengthDelimited) {
            for (let e = reader.int32() + reader.pos; reader.pos < e; ) {
              message.d.push(reader.double());
            }
          } else {
            message.d.push(reader.double());
          }
          break;
        case /* repeated double K = 6 [json_name = "K"]; */ 6:
          if (wireType === WireType.LengthDelimited) {
            for (let e = reader.int32() + reader.pos; reader.pos < e; ) {
              message.k.push(reader.double());
            }
          } else {
            message.k.push(reader.double());
          }
          break;
        case /* repeated double R = 7 [json_name = "R"]; */ 7:
          if (wireType === WireType.LengthDelimited) {
            for (let e = reader.int32() + reader.pos; reader.pos < e; ) {
              message.r.push(reader.double());
            }
          } else {
            message.r.push(reader.double());
          }
          break;
        case /* repeated double P = 8 [json_name = "P"]; */ 8:
          if (wireType === WireType.LengthDelimited) {
            for (let e = reader.int32() + reader.pos; reader.pos < e; ) {
              message.p.push(reader.double());
            }
          } else {
            message.p.push(reader.double());
          }
          break;
        case /* uint32 binning_x */ 9:
          message.binningX = reader.uint32();
          break;
        case /* uint32 binning_y */ 10:
          message.binningY = reader.uint32();
          break;
        case /* kachaka_api.RegionOfInterest roi */ 11:
          message.roi = RegionOfInterest.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.roi,
          );
          break;
        default:
          const u = options.readUnknownField;
          if (u === 'throw') {
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          }
          const d = reader.skip(wireType);
          if (u !== false) {
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
          }
      }
    }
    return message;
  }

  internalBinaryWrite(
    message: RosCameraInfo,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* kachaka_api.RosHeader header = 1; */
    if (message.header) {
      RosHeader.internalBinaryWrite(
        message.header,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    }
    /* uint32 height = 2; */
    if (message.height !== 0) {
      writer.tag(2, WireType.Varint).uint32(message.height);
    }
    /* uint32 width = 3; */
    if (message.width !== 0) {
      writer.tag(3, WireType.Varint).uint32(message.width);
    }
    /* string distortion_model = 4; */
    if (message.distortionModel !== '') {
      writer.tag(4, WireType.LengthDelimited).string(message.distortionModel);
    }
    /* repeated double D = 5 [json_name = "D"]; */
    if (message.d.length > 0) {
      writer.tag(5, WireType.LengthDelimited).fork();
      for (let i = 0; i < message.d.length; i++) {
        writer.double(message.d[i]);
      }
      writer.join();
    }
    /* repeated double K = 6 [json_name = "K"]; */
    if (message.k.length > 0) {
      writer.tag(6, WireType.LengthDelimited).fork();
      for (let i = 0; i < message.k.length; i++) {
        writer.double(message.k[i]);
      }
      writer.join();
    }
    /* repeated double R = 7 [json_name = "R"]; */
    if (message.r.length > 0) {
      writer.tag(7, WireType.LengthDelimited).fork();
      for (let i = 0; i < message.r.length; i++) {
        writer.double(message.r[i]);
      }
      writer.join();
    }
    /* repeated double P = 8 [json_name = "P"]; */
    if (message.p.length > 0) {
      writer.tag(8, WireType.LengthDelimited).fork();
      for (let i = 0; i < message.p.length; i++) {
        writer.double(message.p[i]);
      }
      writer.join();
    }
    /* uint32 binning_x = 9; */
    if (message.binningX !== 0) {
      writer.tag(9, WireType.Varint).uint32(message.binningX);
    }
    /* uint32 binning_y = 10; */
    if (message.binningY !== 0) {
      writer.tag(10, WireType.Varint).uint32(message.binningY);
    }
    /* kachaka_api.RegionOfInterest roi = 11; */
    if (message.roi) {
      RegionOfInterest.internalBinaryWrite(
        message.roi,
        writer.tag(11, WireType.LengthDelimited).fork(),
        options,
      ).join();
    }
    const u = options.writeUnknownFields;
    if (u !== false) {
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    }
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message kachaka_api.RosCameraInfo
 */
export const RosCameraInfo = new RosCameraInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RosImage$Type extends MessageType<RosImage> {
  constructor() {
    super('kachaka_api.RosImage', [
      { no: 1, name: 'header', kind: 'message', T: () => RosHeader },
      { no: 2, name: 'height', kind: 'scalar', T: 13 /* ScalarType.UINT32 */ },
      { no: 3, name: 'width', kind: 'scalar', T: 13 /* ScalarType.UINT32 */ },
      { no: 4, name: 'encoding', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
      {
        no: 5,
        name: 'is_bigendian',
        kind: 'scalar',
        T: 8 /* ScalarType.BOOL */,
      },
      { no: 6, name: 'step', kind: 'scalar', T: 13 /* ScalarType.UINT32 */ },
      { no: 7, name: 'data', kind: 'scalar', T: 12 /* ScalarType.BYTES */ },
    ]);
  }

  create(value?: PartialMessage<RosImage>): RosImage {
    const message = {
      height: 0,
      width: 0,
      encoding: '',
      isBigendian: false,
      step: 0,
      data: new Uint8Array(0),
    };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined) {
      reflectionMergePartial<RosImage>(this, message, value);
    }
    return message;
  }

  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: RosImage,
  ): RosImage {
    const message = target ?? this.create();
    const end = reader.pos + length;
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* kachaka_api.RosHeader header */ 1:
          message.header = RosHeader.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.header,
          );
          break;
        case /* uint32 height */ 2:
          message.height = reader.uint32();
          break;
        case /* uint32 width */ 3:
          message.width = reader.uint32();
          break;
        case /* string encoding */ 4:
          message.encoding = reader.string();
          break;
        case /* bool is_bigendian */ 5:
          message.isBigendian = reader.bool();
          break;
        case /* uint32 step */ 6:
          message.step = reader.uint32();
          break;
        case /* bytes data */ 7:
          message.data = reader.bytes();
          break;
        default:
          const u = options.readUnknownField;
          if (u === 'throw') {
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          }
          const d = reader.skip(wireType);
          if (u !== false) {
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
          }
      }
    }
    return message;
  }

  internalBinaryWrite(
    message: RosImage,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* kachaka_api.RosHeader header = 1; */
    if (message.header) {
      RosHeader.internalBinaryWrite(
        message.header,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    }
    /* uint32 height = 2; */
    if (message.height !== 0) {
      writer.tag(2, WireType.Varint).uint32(message.height);
    }
    /* uint32 width = 3; */
    if (message.width !== 0) {
      writer.tag(3, WireType.Varint).uint32(message.width);
    }
    /* string encoding = 4; */
    if (message.encoding !== '') {
      writer.tag(4, WireType.LengthDelimited).string(message.encoding);
    }
    /* bool is_bigendian = 5; */
    if (message.isBigendian) {
      writer.tag(5, WireType.Varint).bool(message.isBigendian);
    }
    /* uint32 step = 6; */
    if (message.step !== 0) {
      writer.tag(6, WireType.Varint).uint32(message.step);
    }
    /* bytes data = 7; */
    if (message.data.length) {
      writer.tag(7, WireType.LengthDelimited).bytes(message.data);
    }
    const u = options.writeUnknownFields;
    if (u !== false) {
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    }
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message kachaka_api.RosImage
 */
export const RosImage = new RosImage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RosCompressedImage$Type extends MessageType<RosCompressedImage> {
  constructor() {
    super('kachaka_api.RosCompressedImage', [
      { no: 1, name: 'header', kind: 'message', T: () => RosHeader },
      { no: 2, name: 'format', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
      { no: 3, name: 'data', kind: 'scalar', T: 12 /* ScalarType.BYTES */ },
    ]);
  }

  create(value?: PartialMessage<RosCompressedImage>): RosCompressedImage {
    const message = { format: '', data: new Uint8Array(0) };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined) {
      reflectionMergePartial<RosCompressedImage>(this, message, value);
    }
    return message;
  }

  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: RosCompressedImage,
  ): RosCompressedImage {
    const message = target ?? this.create();
    const end = reader.pos + length;
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* kachaka_api.RosHeader header */ 1:
          message.header = RosHeader.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.header,
          );
          break;
        case /* string format */ 2:
          message.format = reader.string();
          break;
        case /* bytes data */ 3:
          message.data = reader.bytes();
          break;
        default:
          const u = options.readUnknownField;
          if (u === 'throw') {
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          }
          const d = reader.skip(wireType);
          if (u !== false) {
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
          }
      }
    }
    return message;
  }

  internalBinaryWrite(
    message: RosCompressedImage,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* kachaka_api.RosHeader header = 1; */
    if (message.header) {
      RosHeader.internalBinaryWrite(
        message.header,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    }
    /* string format = 2; */
    if (message.format !== '') {
      writer.tag(2, WireType.LengthDelimited).string(message.format);
    }
    /* bytes data = 3; */
    if (message.data.length) {
      writer.tag(3, WireType.LengthDelimited).bytes(message.data);
    }
    const u = options.writeUnknownFields;
    if (u !== false) {
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    }
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message kachaka_api.RosCompressedImage
 */
export const RosCompressedImage = new RosCompressedImage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ObjectDetection$Type extends MessageType<ObjectDetection> {
  constructor() {
    super('kachaka_api.ObjectDetection', [
      { no: 1, name: 'label', kind: 'scalar', T: 13 /* ScalarType.UINT32 */ },
      { no: 2, name: 'roi', kind: 'message', T: () => RegionOfInterest },
      { no: 3, name: 'score', kind: 'scalar', T: 2 /* ScalarType.FLOAT */ },
      {
        no: 4,
        name: 'distance_median',
        kind: 'scalar',
        T: 1 /* ScalarType.DOUBLE */,
      },
    ]);
  }

  create(value?: PartialMessage<ObjectDetection>): ObjectDetection {
    const message = { label: 0, score: 0, distanceMedian: 0 };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined) {
      reflectionMergePartial<ObjectDetection>(this, message, value);
    }
    return message;
  }

  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ObjectDetection,
  ): ObjectDetection {
    const message = target ?? this.create();
    const end = reader.pos + length;
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* uint32 label */ 1:
          message.label = reader.uint32();
          break;
        case /* kachaka_api.RegionOfInterest roi */ 2:
          message.roi = RegionOfInterest.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.roi,
          );
          break;
        case /* float score */ 3:
          message.score = reader.float();
          break;
        case /* double distance_median */ 4:
          message.distanceMedian = reader.double();
          break;
        default:
          const u = options.readUnknownField;
          if (u === 'throw') {
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          }
          const d = reader.skip(wireType);
          if (u !== false) {
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
          }
      }
    }
    return message;
  }

  internalBinaryWrite(
    message: ObjectDetection,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* uint32 label = 1; */
    if (message.label !== 0) {
      writer.tag(1, WireType.Varint).uint32(message.label);
    }
    /* kachaka_api.RegionOfInterest roi = 2; */
    if (message.roi) {
      RegionOfInterest.internalBinaryWrite(
        message.roi,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    }
    /* float score = 3; */
    if (message.score !== 0) {
      writer.tag(3, WireType.Bit32).float(message.score);
    }
    /* double distance_median = 4; */
    if (message.distanceMedian !== 0) {
      writer.tag(4, WireType.Bit64).double(message.distanceMedian);
    }
    const u = options.writeUnknownFields;
    if (u !== false) {
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    }
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message kachaka_api.ObjectDetection
 */
export const ObjectDetection = new ObjectDetection$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Command$Type extends MessageType<Command> {
  constructor() {
    super('kachaka_api.Command', [
      {
        no: 1,
        name: 'move_shelf_command',
        kind: 'message',
        oneof: 'command',
        T: () => MoveShelfCommand,
      },
      {
        no: 2,
        name: 'return_shelf_command',
        kind: 'message',
        oneof: 'command',
        T: () => ReturnShelfCommand,
      },
      {
        no: 5,
        name: 'undock_shelf_command',
        kind: 'message',
        oneof: 'command',
        T: () => UndockShelfCommand,
      },
      {
        no: 7,
        name: 'move_to_location_command',
        kind: 'message',
        oneof: 'command',
        T: () => MoveToLocationCommand,
      },
      {
        no: 8,
        name: 'return_home_command',
        kind: 'message',
        oneof: 'command',
        T: () => ReturnHomeCommand,
      },
      {
        no: 9,
        name: 'dock_shelf_command',
        kind: 'message',
        oneof: 'command',
        T: () => DockShelfCommand,
      },
      {
        no: 12,
        name: 'speak_command',
        kind: 'message',
        oneof: 'command',
        T: () => SpeakCommand,
      },
      {
        no: 13,
        name: 'move_to_pose_command',
        kind: 'message',
        oneof: 'command',
        T: () => MoveToPoseCommand,
      },
    ]);
  }

  create(value?: PartialMessage<Command>): Command {
    const message = { command: { oneofKind: undefined } };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined) {
      reflectionMergePartial<Command>(this, message, value);
    }
    return message;
  }

  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: Command,
  ): Command {
    const message = target ?? this.create();
    const end = reader.pos + length;
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* kachaka_api.MoveShelfCommand move_shelf_command */ 1:
          message.command = {
            oneofKind: 'moveShelfCommand',
            moveShelfCommand: MoveShelfCommand.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              (message.command as any).moveShelfCommand,
            ),
          };
          break;
        case /* kachaka_api.ReturnShelfCommand return_shelf_command */ 2:
          message.command = {
            oneofKind: 'returnShelfCommand',
            returnShelfCommand: ReturnShelfCommand.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              (message.command as any).returnShelfCommand,
            ),
          };
          break;
        case /* kachaka_api.UndockShelfCommand undock_shelf_command */ 5:
          message.command = {
            oneofKind: 'undockShelfCommand',
            undockShelfCommand: UndockShelfCommand.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              (message.command as any).undockShelfCommand,
            ),
          };
          break;
        case /* kachaka_api.MoveToLocationCommand move_to_location_command */ 7:
          message.command = {
            oneofKind: 'moveToLocationCommand',
            moveToLocationCommand: MoveToLocationCommand.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              (message.command as any).moveToLocationCommand,
            ),
          };
          break;
        case /* kachaka_api.ReturnHomeCommand return_home_command */ 8:
          message.command = {
            oneofKind: 'returnHomeCommand',
            returnHomeCommand: ReturnHomeCommand.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              (message.command as any).returnHomeCommand,
            ),
          };
          break;
        case /* kachaka_api.DockShelfCommand dock_shelf_command */ 9:
          message.command = {
            oneofKind: 'dockShelfCommand',
            dockShelfCommand: DockShelfCommand.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              (message.command as any).dockShelfCommand,
            ),
          };
          break;
        case /* kachaka_api.SpeakCommand speak_command */ 12:
          message.command = {
            oneofKind: 'speakCommand',
            speakCommand: SpeakCommand.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              (message.command as any).speakCommand,
            ),
          };
          break;
        case /* kachaka_api.MoveToPoseCommand move_to_pose_command */ 13:
          message.command = {
            oneofKind: 'moveToPoseCommand',
            moveToPoseCommand: MoveToPoseCommand.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              (message.command as any).moveToPoseCommand,
            ),
          };
          break;
        default:
          const u = options.readUnknownField;
          if (u === 'throw') {
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          }
          const d = reader.skip(wireType);
          if (u !== false) {
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
          }
      }
    }
    return message;
  }

  internalBinaryWrite(
    message: Command,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* kachaka_api.MoveShelfCommand move_shelf_command = 1; */
    if (message.command.oneofKind === 'moveShelfCommand') {
      MoveShelfCommand.internalBinaryWrite(
        message.command.moveShelfCommand,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    }
    /* kachaka_api.ReturnShelfCommand return_shelf_command = 2; */
    if (message.command.oneofKind === 'returnShelfCommand') {
      ReturnShelfCommand.internalBinaryWrite(
        message.command.returnShelfCommand,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    }
    /* kachaka_api.UndockShelfCommand undock_shelf_command = 5; */
    if (message.command.oneofKind === 'undockShelfCommand') {
      UndockShelfCommand.internalBinaryWrite(
        message.command.undockShelfCommand,
        writer.tag(5, WireType.LengthDelimited).fork(),
        options,
      ).join();
    }
    /* kachaka_api.MoveToLocationCommand move_to_location_command = 7; */
    if (message.command.oneofKind === 'moveToLocationCommand') {
      MoveToLocationCommand.internalBinaryWrite(
        message.command.moveToLocationCommand,
        writer.tag(7, WireType.LengthDelimited).fork(),
        options,
      ).join();
    }
    /* kachaka_api.ReturnHomeCommand return_home_command = 8; */
    if (message.command.oneofKind === 'returnHomeCommand') {
      ReturnHomeCommand.internalBinaryWrite(
        message.command.returnHomeCommand,
        writer.tag(8, WireType.LengthDelimited).fork(),
        options,
      ).join();
    }
    /* kachaka_api.DockShelfCommand dock_shelf_command = 9; */
    if (message.command.oneofKind === 'dockShelfCommand') {
      DockShelfCommand.internalBinaryWrite(
        message.command.dockShelfCommand,
        writer.tag(9, WireType.LengthDelimited).fork(),
        options,
      ).join();
    }
    /* kachaka_api.SpeakCommand speak_command = 12; */
    if (message.command.oneofKind === 'speakCommand') {
      SpeakCommand.internalBinaryWrite(
        message.command.speakCommand,
        writer.tag(12, WireType.LengthDelimited).fork(),
        options,
      ).join();
    }
    /* kachaka_api.MoveToPoseCommand move_to_pose_command = 13; */
    if (message.command.oneofKind === 'moveToPoseCommand') {
      MoveToPoseCommand.internalBinaryWrite(
        message.command.moveToPoseCommand,
        writer.tag(13, WireType.LengthDelimited).fork(),
        options,
      ).join();
    }
    const u = options.writeUnknownFields;
    if (u !== false) {
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    }
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message kachaka_api.Command
 */
export const Command = new Command$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MoveShelfCommand$Type extends MessageType<MoveShelfCommand> {
  constructor() {
    super('kachaka_api.MoveShelfCommand', [
      {
        no: 1,
        name: 'target_shelf_id',
        kind: 'scalar',
        T: 9 /* ScalarType.STRING */,
      },
      {
        no: 2,
        name: 'destination_location_id',
        kind: 'scalar',
        T: 9 /* ScalarType.STRING */,
      },
    ]);
  }

  create(value?: PartialMessage<MoveShelfCommand>): MoveShelfCommand {
    const message = { targetShelfId: '', destinationLocationId: '' };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined) {
      reflectionMergePartial<MoveShelfCommand>(this, message, value);
    }
    return message;
  }

  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: MoveShelfCommand,
  ): MoveShelfCommand {
    const message = target ?? this.create();
    const end = reader.pos + length;
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string target_shelf_id */ 1:
          message.targetShelfId = reader.string();
          break;
        case /* string destination_location_id */ 2:
          message.destinationLocationId = reader.string();
          break;
        default:
          const u = options.readUnknownField;
          if (u === 'throw') {
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          }
          const d = reader.skip(wireType);
          if (u !== false) {
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
          }
      }
    }
    return message;
  }

  internalBinaryWrite(
    message: MoveShelfCommand,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string target_shelf_id = 1; */
    if (message.targetShelfId !== '') {
      writer.tag(1, WireType.LengthDelimited).string(message.targetShelfId);
    }
    /* string destination_location_id = 2; */
    if (message.destinationLocationId !== '') {
      writer
        .tag(2, WireType.LengthDelimited)
        .string(message.destinationLocationId);
    }
    const u = options.writeUnknownFields;
    if (u !== false) {
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    }
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message kachaka_api.MoveShelfCommand
 */
export const MoveShelfCommand = new MoveShelfCommand$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReturnShelfCommand$Type extends MessageType<ReturnShelfCommand> {
  constructor() {
    super('kachaka_api.ReturnShelfCommand', [
      {
        no: 1,
        name: 'target_shelf_id',
        kind: 'scalar',
        T: 9 /* ScalarType.STRING */,
      },
    ]);
  }

  create(value?: PartialMessage<ReturnShelfCommand>): ReturnShelfCommand {
    const message = { targetShelfId: '' };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined) {
      reflectionMergePartial<ReturnShelfCommand>(this, message, value);
    }
    return message;
  }

  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ReturnShelfCommand,
  ): ReturnShelfCommand {
    const message = target ?? this.create();
    const end = reader.pos + length;
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string target_shelf_id */ 1:
          message.targetShelfId = reader.string();
          break;
        default:
          const u = options.readUnknownField;
          if (u === 'throw') {
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          }
          const d = reader.skip(wireType);
          if (u !== false) {
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
          }
      }
    }
    return message;
  }

  internalBinaryWrite(
    message: ReturnShelfCommand,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string target_shelf_id = 1; */
    if (message.targetShelfId !== '') {
      writer.tag(1, WireType.LengthDelimited).string(message.targetShelfId);
    }
    const u = options.writeUnknownFields;
    if (u !== false) {
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    }
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message kachaka_api.ReturnShelfCommand
 */
export const ReturnShelfCommand = new ReturnShelfCommand$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UndockShelfCommand$Type extends MessageType<UndockShelfCommand> {
  constructor() {
    super('kachaka_api.UndockShelfCommand', [
      {
        no: 1,
        name: 'target_shelf_id',
        kind: 'scalar',
        T: 9 /* ScalarType.STRING */,
      },
    ]);
  }

  create(value?: PartialMessage<UndockShelfCommand>): UndockShelfCommand {
    const message = { targetShelfId: '' };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined) {
      reflectionMergePartial<UndockShelfCommand>(this, message, value);
    }
    return message;
  }

  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: UndockShelfCommand,
  ): UndockShelfCommand {
    const message = target ?? this.create();
    const end = reader.pos + length;
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string target_shelf_id */ 1:
          message.targetShelfId = reader.string();
          break;
        default:
          const u = options.readUnknownField;
          if (u === 'throw') {
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          }
          const d = reader.skip(wireType);
          if (u !== false) {
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
          }
      }
    }
    return message;
  }

  internalBinaryWrite(
    message: UndockShelfCommand,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string target_shelf_id = 1; */
    if (message.targetShelfId !== '') {
      writer.tag(1, WireType.LengthDelimited).string(message.targetShelfId);
    }
    const u = options.writeUnknownFields;
    if (u !== false) {
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    }
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message kachaka_api.UndockShelfCommand
 */
export const UndockShelfCommand = new UndockShelfCommand$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MoveToLocationCommand$Type extends MessageType<MoveToLocationCommand> {
  constructor() {
    super('kachaka_api.MoveToLocationCommand', [
      {
        no: 1,
        name: 'target_location_id',
        kind: 'scalar',
        T: 9 /* ScalarType.STRING */,
      },
    ]);
  }

  create(value?: PartialMessage<MoveToLocationCommand>): MoveToLocationCommand {
    const message = { targetLocationId: '' };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined) {
      reflectionMergePartial<MoveToLocationCommand>(this, message, value);
    }
    return message;
  }

  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: MoveToLocationCommand,
  ): MoveToLocationCommand {
    const message = target ?? this.create();
    const end = reader.pos + length;
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string target_location_id */ 1:
          message.targetLocationId = reader.string();
          break;
        default:
          const u = options.readUnknownField;
          if (u === 'throw') {
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          }
          const d = reader.skip(wireType);
          if (u !== false) {
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
          }
      }
    }
    return message;
  }

  internalBinaryWrite(
    message: MoveToLocationCommand,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string target_location_id = 1; */
    if (message.targetLocationId !== '') {
      writer.tag(1, WireType.LengthDelimited).string(message.targetLocationId);
    }
    const u = options.writeUnknownFields;
    if (u !== false) {
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    }
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message kachaka_api.MoveToLocationCommand
 */
export const MoveToLocationCommand = new MoveToLocationCommand$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReturnHomeCommand$Type extends MessageType<ReturnHomeCommand> {
  constructor() {
    super('kachaka_api.ReturnHomeCommand', []);
  }

  create(value?: PartialMessage<ReturnHomeCommand>): ReturnHomeCommand {
    const message = {};
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined) {
      reflectionMergePartial<ReturnHomeCommand>(this, message, value);
    }
    return message;
  }

  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ReturnHomeCommand,
  ): ReturnHomeCommand {
    return target ?? this.create();
  }

  internalBinaryWrite(
    message: ReturnHomeCommand,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    const u = options.writeUnknownFields;
    if (u !== false) {
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    }
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message kachaka_api.ReturnHomeCommand
 */
export const ReturnHomeCommand = new ReturnHomeCommand$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DockShelfCommand$Type extends MessageType<DockShelfCommand> {
  constructor() {
    super('kachaka_api.DockShelfCommand', []);
  }

  create(value?: PartialMessage<DockShelfCommand>): DockShelfCommand {
    const message = {};
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined) {
      reflectionMergePartial<DockShelfCommand>(this, message, value);
    }
    return message;
  }

  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: DockShelfCommand,
  ): DockShelfCommand {
    return target ?? this.create();
  }

  internalBinaryWrite(
    message: DockShelfCommand,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    const u = options.writeUnknownFields;
    if (u !== false) {
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    }
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message kachaka_api.DockShelfCommand
 */
export const DockShelfCommand = new DockShelfCommand$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SpeakCommand$Type extends MessageType<SpeakCommand> {
  constructor() {
    super('kachaka_api.SpeakCommand', [
      { no: 1, name: 'text', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    ]);
  }

  create(value?: PartialMessage<SpeakCommand>): SpeakCommand {
    const message = { text: '' };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined) {
      reflectionMergePartial<SpeakCommand>(this, message, value);
    }
    return message;
  }

  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: SpeakCommand,
  ): SpeakCommand {
    const message = target ?? this.create();
    const end = reader.pos + length;
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string text */ 1:
          message.text = reader.string();
          break;
        default:
          const u = options.readUnknownField;
          if (u === 'throw') {
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          }
          const d = reader.skip(wireType);
          if (u !== false) {
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
          }
      }
    }
    return message;
  }

  internalBinaryWrite(
    message: SpeakCommand,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string text = 1; */
    if (message.text !== '') {
      writer.tag(1, WireType.LengthDelimited).string(message.text);
    }
    const u = options.writeUnknownFields;
    if (u !== false) {
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    }
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message kachaka_api.SpeakCommand
 */
export const SpeakCommand = new SpeakCommand$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MoveToPoseCommand$Type extends MessageType<MoveToPoseCommand> {
  constructor() {
    super('kachaka_api.MoveToPoseCommand', [
      { no: 1, name: 'x', kind: 'scalar', T: 1 /* ScalarType.DOUBLE */ },
      { no: 2, name: 'y', kind: 'scalar', T: 1 /* ScalarType.DOUBLE */ },
      { no: 3, name: 'yaw', kind: 'scalar', T: 1 /* ScalarType.DOUBLE */ },
    ]);
  }

  create(value?: PartialMessage<MoveToPoseCommand>): MoveToPoseCommand {
    const message = { x: 0, y: 0, yaw: 0 };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined) {
      reflectionMergePartial<MoveToPoseCommand>(this, message, value);
    }
    return message;
  }

  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: MoveToPoseCommand,
  ): MoveToPoseCommand {
    const message = target ?? this.create();
    const end = reader.pos + length;
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* double x */ 1:
          message.x = reader.double();
          break;
        case /* double y */ 2:
          message.y = reader.double();
          break;
        case /* double yaw */ 3:
          message.yaw = reader.double();
          break;
        default:
          const u = options.readUnknownField;
          if (u === 'throw') {
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          }
          const d = reader.skip(wireType);
          if (u !== false) {
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
          }
      }
    }
    return message;
  }

  internalBinaryWrite(
    message: MoveToPoseCommand,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* double x = 1; */
    if (message.x !== 0) {
      writer.tag(1, WireType.Bit64).double(message.x);
    }
    /* double y = 2; */
    if (message.y !== 0) {
      writer.tag(2, WireType.Bit64).double(message.y);
    }
    /* double yaw = 3; */
    if (message.yaw !== 0) {
      writer.tag(3, WireType.Bit64).double(message.yaw);
    }
    const u = options.writeUnknownFields;
    if (u !== false) {
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    }
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message kachaka_api.MoveToPoseCommand
 */
export const MoveToPoseCommand = new MoveToPoseCommand$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EmptyRequest$Type extends MessageType<EmptyRequest> {
  constructor() {
    super('kachaka_api.EmptyRequest', []);
  }

  create(value?: PartialMessage<EmptyRequest>): EmptyRequest {
    const message = {};
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined) {
      reflectionMergePartial<EmptyRequest>(this, message, value);
    }
    return message;
  }

  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: EmptyRequest,
  ): EmptyRequest {
    return target ?? this.create();
  }

  internalBinaryWrite(
    message: EmptyRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    const u = options.writeUnknownFields;
    if (u !== false) {
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    }
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message kachaka_api.EmptyRequest
 */
export const EmptyRequest = new EmptyRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetRequest$Type extends MessageType<GetRequest> {
  constructor() {
    super('kachaka_api.GetRequest', [
      { no: 1, name: 'metadata', kind: 'message', T: () => Metadata },
    ]);
  }

  create(value?: PartialMessage<GetRequest>): GetRequest {
    const message = {};
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined) {
      reflectionMergePartial<GetRequest>(this, message, value);
    }
    return message;
  }

  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: GetRequest,
  ): GetRequest {
    const message = target ?? this.create();
    const end = reader.pos + length;
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* kachaka_api.Metadata metadata */ 1:
          message.metadata = Metadata.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.metadata,
          );
          break;
        default:
          const u = options.readUnknownField;
          if (u === 'throw') {
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          }
          const d = reader.skip(wireType);
          if (u !== false) {
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
          }
      }
    }
    return message;
  }

  internalBinaryWrite(
    message: GetRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* kachaka_api.Metadata metadata = 1; */
    if (message.metadata) {
      Metadata.internalBinaryWrite(
        message.metadata,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    }
    const u = options.writeUnknownFields;
    if (u !== false) {
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    }
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message kachaka_api.GetRequest
 */
export const GetRequest = new GetRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetRobotSerialNumberResponse$Type extends MessageType<GetRobotSerialNumberResponse> {
  constructor() {
    super('kachaka_api.GetRobotSerialNumberResponse', [
      { no: 1, name: 'metadata', kind: 'message', T: () => Metadata },
      {
        no: 2,
        name: 'serial_number',
        kind: 'scalar',
        T: 9 /* ScalarType.STRING */,
      },
    ]);
  }

  create(
    value?: PartialMessage<GetRobotSerialNumberResponse>,
  ): GetRobotSerialNumberResponse {
    const message = { serialNumber: '' };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined) {
      reflectionMergePartial<GetRobotSerialNumberResponse>(
        this,
        message,
        value,
      );
    }
    return message;
  }

  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: GetRobotSerialNumberResponse,
  ): GetRobotSerialNumberResponse {
    const message = target ?? this.create();
    const end = reader.pos + length;
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* kachaka_api.Metadata metadata */ 1:
          message.metadata = Metadata.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.metadata,
          );
          break;
        case /* string serial_number */ 2:
          message.serialNumber = reader.string();
          break;
        default:
          const u = options.readUnknownField;
          if (u === 'throw') {
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          }
          const d = reader.skip(wireType);
          if (u !== false) {
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
          }
      }
    }
    return message;
  }

  internalBinaryWrite(
    message: GetRobotSerialNumberResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* kachaka_api.Metadata metadata = 1; */
    if (message.metadata) {
      Metadata.internalBinaryWrite(
        message.metadata,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    }
    /* string serial_number = 2; */
    if (message.serialNumber !== '') {
      writer.tag(2, WireType.LengthDelimited).string(message.serialNumber);
    }
    const u = options.writeUnknownFields;
    if (u !== false) {
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    }
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message kachaka_api.GetRobotSerialNumberResponse
 */
export const GetRobotSerialNumberResponse =
  new GetRobotSerialNumberResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetRobotVersionResponse$Type extends MessageType<GetRobotVersionResponse> {
  constructor() {
    super('kachaka_api.GetRobotVersionResponse', [
      { no: 1, name: 'metadata', kind: 'message', T: () => Metadata },
      { no: 2, name: 'version', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    ]);
  }

  create(
    value?: PartialMessage<GetRobotVersionResponse>,
  ): GetRobotVersionResponse {
    const message = { version: '' };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined) {
      reflectionMergePartial<GetRobotVersionResponse>(this, message, value);
    }
    return message;
  }

  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: GetRobotVersionResponse,
  ): GetRobotVersionResponse {
    const message = target ?? this.create();
    const end = reader.pos + length;
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* kachaka_api.Metadata metadata */ 1:
          message.metadata = Metadata.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.metadata,
          );
          break;
        case /* string version */ 2:
          message.version = reader.string();
          break;
        default:
          const u = options.readUnknownField;
          if (u === 'throw') {
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          }
          const d = reader.skip(wireType);
          if (u !== false) {
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
          }
      }
    }
    return message;
  }

  internalBinaryWrite(
    message: GetRobotVersionResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* kachaka_api.Metadata metadata = 1; */
    if (message.metadata) {
      Metadata.internalBinaryWrite(
        message.metadata,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    }
    /* string version = 2; */
    if (message.version !== '') {
      writer.tag(2, WireType.LengthDelimited).string(message.version);
    }
    const u = options.writeUnknownFields;
    if (u !== false) {
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    }
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message kachaka_api.GetRobotVersionResponse
 */
export const GetRobotVersionResponse = new GetRobotVersionResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetRobotPoseResponse$Type extends MessageType<GetRobotPoseResponse> {
  constructor() {
    super('kachaka_api.GetRobotPoseResponse', [
      { no: 1, name: 'metadata', kind: 'message', T: () => Metadata },
      { no: 2, name: 'pose', kind: 'message', T: () => Pose },
    ]);
  }

  create(value?: PartialMessage<GetRobotPoseResponse>): GetRobotPoseResponse {
    const message = {};
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined) {
      reflectionMergePartial<GetRobotPoseResponse>(this, message, value);
    }
    return message;
  }

  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: GetRobotPoseResponse,
  ): GetRobotPoseResponse {
    const message = target ?? this.create();
    const end = reader.pos + length;
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* kachaka_api.Metadata metadata */ 1:
          message.metadata = Metadata.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.metadata,
          );
          break;
        case /* kachaka_api.Pose pose */ 2:
          message.pose = Pose.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.pose,
          );
          break;
        default:
          const u = options.readUnknownField;
          if (u === 'throw') {
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          }
          const d = reader.skip(wireType);
          if (u !== false) {
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
          }
      }
    }
    return message;
  }

  internalBinaryWrite(
    message: GetRobotPoseResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* kachaka_api.Metadata metadata = 1; */
    if (message.metadata) {
      Metadata.internalBinaryWrite(
        message.metadata,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    }
    /* kachaka_api.Pose pose = 2; */
    if (message.pose) {
      Pose.internalBinaryWrite(
        message.pose,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    }
    const u = options.writeUnknownFields;
    if (u !== false) {
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    }
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message kachaka_api.GetRobotPoseResponse
 */
export const GetRobotPoseResponse = new GetRobotPoseResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetPngMapResponse$Type extends MessageType<GetPngMapResponse> {
  constructor() {
    super('kachaka_api.GetPngMapResponse', [
      { no: 1, name: 'metadata', kind: 'message', T: () => Metadata },
      { no: 2, name: 'map', kind: 'message', T: () => Map },
    ]);
  }

  create(value?: PartialMessage<GetPngMapResponse>): GetPngMapResponse {
    const message = {};
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined) {
      reflectionMergePartial<GetPngMapResponse>(this, message, value);
    }
    return message;
  }

  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: GetPngMapResponse,
  ): GetPngMapResponse {
    const message = target ?? this.create();
    const end = reader.pos + length;
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* kachaka_api.Metadata metadata */ 1:
          message.metadata = Metadata.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.metadata,
          );
          break;
        case /* kachaka_api.Map map */ 2:
          message.map = Map.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.map,
          );
          break;
        default:
          const u = options.readUnknownField;
          if (u === 'throw') {
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          }
          const d = reader.skip(wireType);
          if (u !== false) {
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
          }
      }
    }
    return message;
  }

  internalBinaryWrite(
    message: GetPngMapResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* kachaka_api.Metadata metadata = 1; */
    if (message.metadata) {
      Metadata.internalBinaryWrite(
        message.metadata,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    }
    /* kachaka_api.Map map = 2; */
    if (message.map) {
      Map.internalBinaryWrite(
        message.map,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    }
    const u = options.writeUnknownFields;
    if (u !== false) {
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    }
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message kachaka_api.GetPngMapResponse
 */
export const GetPngMapResponse = new GetPngMapResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetObjectDetectionResponse$Type extends MessageType<GetObjectDetectionResponse> {
  constructor() {
    super('kachaka_api.GetObjectDetectionResponse', [
      { no: 1, name: 'metadata', kind: 'message', T: () => Metadata },
      { no: 2, name: 'header', kind: 'message', T: () => RosHeader },
      {
        no: 3,
        name: 'objects',
        kind: 'message',
        repeat: 1 /* RepeatType.PACKED */,
        T: () => ObjectDetection,
      },
    ]);
  }

  create(
    value?: PartialMessage<GetObjectDetectionResponse>,
  ): GetObjectDetectionResponse {
    const message = { objects: [] };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined) {
      reflectionMergePartial<GetObjectDetectionResponse>(this, message, value);
    }
    return message;
  }

  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: GetObjectDetectionResponse,
  ): GetObjectDetectionResponse {
    const message = target ?? this.create();
    const end = reader.pos + length;
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* kachaka_api.Metadata metadata */ 1:
          message.metadata = Metadata.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.metadata,
          );
          break;
        case /* kachaka_api.RosHeader header */ 2:
          message.header = RosHeader.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.header,
          );
          break;
        case /* repeated kachaka_api.ObjectDetection objects */ 3:
          message.objects.push(
            ObjectDetection.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
            ),
          );
          break;
        default:
          const u = options.readUnknownField;
          if (u === 'throw') {
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          }
          const d = reader.skip(wireType);
          if (u !== false) {
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
          }
      }
    }
    return message;
  }

  internalBinaryWrite(
    message: GetObjectDetectionResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* kachaka_api.Metadata metadata = 1; */
    if (message.metadata) {
      Metadata.internalBinaryWrite(
        message.metadata,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    }
    /* kachaka_api.RosHeader header = 2; */
    if (message.header) {
      RosHeader.internalBinaryWrite(
        message.header,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    }
    /* repeated kachaka_api.ObjectDetection objects = 3; */
    for (let i = 0; i < message.objects.length; i++) {
      ObjectDetection.internalBinaryWrite(
        message.objects[i],
        writer.tag(3, WireType.LengthDelimited).fork(),
        options,
      ).join();
    }
    const u = options.writeUnknownFields;
    if (u !== false) {
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    }
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message kachaka_api.GetObjectDetectionResponse
 */
export const GetObjectDetectionResponse = new GetObjectDetectionResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetRosImuResponse$Type extends MessageType<GetRosImuResponse> {
  constructor() {
    super('kachaka_api.GetRosImuResponse', [
      { no: 1, name: 'metadata', kind: 'message', T: () => Metadata },
      { no: 2, name: 'imu', kind: 'message', T: () => RosImu },
    ]);
  }

  create(value?: PartialMessage<GetRosImuResponse>): GetRosImuResponse {
    const message = {};
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined) {
      reflectionMergePartial<GetRosImuResponse>(this, message, value);
    }
    return message;
  }

  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: GetRosImuResponse,
  ): GetRosImuResponse {
    const message = target ?? this.create();
    const end = reader.pos + length;
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* kachaka_api.Metadata metadata */ 1:
          message.metadata = Metadata.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.metadata,
          );
          break;
        case /* kachaka_api.RosImu imu */ 2:
          message.imu = RosImu.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.imu,
          );
          break;
        default:
          const u = options.readUnknownField;
          if (u === 'throw') {
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          }
          const d = reader.skip(wireType);
          if (u !== false) {
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
          }
      }
    }
    return message;
  }

  internalBinaryWrite(
    message: GetRosImuResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* kachaka_api.Metadata metadata = 1; */
    if (message.metadata) {
      Metadata.internalBinaryWrite(
        message.metadata,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    }
    /* kachaka_api.RosImu imu = 2; */
    if (message.imu) {
      RosImu.internalBinaryWrite(
        message.imu,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    }
    const u = options.writeUnknownFields;
    if (u !== false) {
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    }
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message kachaka_api.GetRosImuResponse
 */
export const GetRosImuResponse = new GetRosImuResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetRosOdometryResponse$Type extends MessageType<GetRosOdometryResponse> {
  constructor() {
    super('kachaka_api.GetRosOdometryResponse', [
      { no: 1, name: 'metadata', kind: 'message', T: () => Metadata },
      { no: 2, name: 'odometry', kind: 'message', T: () => RosOdometry },
    ]);
  }

  create(
    value?: PartialMessage<GetRosOdometryResponse>,
  ): GetRosOdometryResponse {
    const message = {};
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined) {
      reflectionMergePartial<GetRosOdometryResponse>(this, message, value);
    }
    return message;
  }

  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: GetRosOdometryResponse,
  ): GetRosOdometryResponse {
    const message = target ?? this.create();
    const end = reader.pos + length;
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* kachaka_api.Metadata metadata */ 1:
          message.metadata = Metadata.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.metadata,
          );
          break;
        case /* kachaka_api.RosOdometry odometry */ 2:
          message.odometry = RosOdometry.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.odometry,
          );
          break;
        default:
          const u = options.readUnknownField;
          if (u === 'throw') {
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          }
          const d = reader.skip(wireType);
          if (u !== false) {
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
          }
      }
    }
    return message;
  }

  internalBinaryWrite(
    message: GetRosOdometryResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* kachaka_api.Metadata metadata = 1; */
    if (message.metadata) {
      Metadata.internalBinaryWrite(
        message.metadata,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    }
    /* kachaka_api.RosOdometry odometry = 2; */
    if (message.odometry) {
      RosOdometry.internalBinaryWrite(
        message.odometry,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    }
    const u = options.writeUnknownFields;
    if (u !== false) {
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    }
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message kachaka_api.GetRosOdometryResponse
 */
export const GetRosOdometryResponse = new GetRosOdometryResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetRosLaserScanResponse$Type extends MessageType<GetRosLaserScanResponse> {
  constructor() {
    super('kachaka_api.GetRosLaserScanResponse', [
      { no: 1, name: 'metadata', kind: 'message', T: () => Metadata },
      { no: 2, name: 'scan', kind: 'message', T: () => RosLaserScan },
    ]);
  }

  create(
    value?: PartialMessage<GetRosLaserScanResponse>,
  ): GetRosLaserScanResponse {
    const message = {};
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined) {
      reflectionMergePartial<GetRosLaserScanResponse>(this, message, value);
    }
    return message;
  }

  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: GetRosLaserScanResponse,
  ): GetRosLaserScanResponse {
    const message = target ?? this.create();
    const end = reader.pos + length;
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* kachaka_api.Metadata metadata */ 1:
          message.metadata = Metadata.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.metadata,
          );
          break;
        case /* kachaka_api.RosLaserScan scan */ 2:
          message.scan = RosLaserScan.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.scan,
          );
          break;
        default:
          const u = options.readUnknownField;
          if (u === 'throw') {
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          }
          const d = reader.skip(wireType);
          if (u !== false) {
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
          }
      }
    }
    return message;
  }

  internalBinaryWrite(
    message: GetRosLaserScanResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* kachaka_api.Metadata metadata = 1; */
    if (message.metadata) {
      Metadata.internalBinaryWrite(
        message.metadata,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    }
    /* kachaka_api.RosLaserScan scan = 2; */
    if (message.scan) {
      RosLaserScan.internalBinaryWrite(
        message.scan,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    }
    const u = options.writeUnknownFields;
    if (u !== false) {
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    }
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message kachaka_api.GetRosLaserScanResponse
 */
export const GetRosLaserScanResponse = new GetRosLaserScanResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetFrontCameraRosCameraInfoResponse$Type extends MessageType<GetFrontCameraRosCameraInfoResponse> {
  constructor() {
    super('kachaka_api.GetFrontCameraRosCameraInfoResponse', [
      { no: 1, name: 'metadata', kind: 'message', T: () => Metadata },
      { no: 2, name: 'camera_info', kind: 'message', T: () => RosCameraInfo },
    ]);
  }

  create(
    value?: PartialMessage<GetFrontCameraRosCameraInfoResponse>,
  ): GetFrontCameraRosCameraInfoResponse {
    const message = {};
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined) {
      reflectionMergePartial<GetFrontCameraRosCameraInfoResponse>(
        this,
        message,
        value,
      );
    }
    return message;
  }

  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: GetFrontCameraRosCameraInfoResponse,
  ): GetFrontCameraRosCameraInfoResponse {
    const message = target ?? this.create();
    const end = reader.pos + length;
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* kachaka_api.Metadata metadata */ 1:
          message.metadata = Metadata.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.metadata,
          );
          break;
        case /* kachaka_api.RosCameraInfo camera_info */ 2:
          message.cameraInfo = RosCameraInfo.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.cameraInfo,
          );
          break;
        default:
          const u = options.readUnknownField;
          if (u === 'throw') {
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          }
          const d = reader.skip(wireType);
          if (u !== false) {
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
          }
      }
    }
    return message;
  }

  internalBinaryWrite(
    message: GetFrontCameraRosCameraInfoResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* kachaka_api.Metadata metadata = 1; */
    if (message.metadata) {
      Metadata.internalBinaryWrite(
        message.metadata,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    }
    /* kachaka_api.RosCameraInfo camera_info = 2; */
    if (message.cameraInfo) {
      RosCameraInfo.internalBinaryWrite(
        message.cameraInfo,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    }
    const u = options.writeUnknownFields;
    if (u !== false) {
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    }
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message kachaka_api.GetFrontCameraRosCameraInfoResponse
 */
export const GetFrontCameraRosCameraInfoResponse =
  new GetFrontCameraRosCameraInfoResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetFrontCameraRosImageResponse$Type extends MessageType<GetFrontCameraRosImageResponse> {
  constructor() {
    super('kachaka_api.GetFrontCameraRosImageResponse', [
      { no: 1, name: 'metadata', kind: 'message', T: () => Metadata },
      { no: 2, name: 'image', kind: 'message', T: () => RosImage },
    ]);
  }

  create(
    value?: PartialMessage<GetFrontCameraRosImageResponse>,
  ): GetFrontCameraRosImageResponse {
    const message = {};
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined) {
      reflectionMergePartial<GetFrontCameraRosImageResponse>(
        this,
        message,
        value,
      );
    }
    return message;
  }

  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: GetFrontCameraRosImageResponse,
  ): GetFrontCameraRosImageResponse {
    const message = target ?? this.create();
    const end = reader.pos + length;
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* kachaka_api.Metadata metadata */ 1:
          message.metadata = Metadata.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.metadata,
          );
          break;
        case /* kachaka_api.RosImage image */ 2:
          message.image = RosImage.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.image,
          );
          break;
        default:
          const u = options.readUnknownField;
          if (u === 'throw') {
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          }
          const d = reader.skip(wireType);
          if (u !== false) {
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
          }
      }
    }
    return message;
  }

  internalBinaryWrite(
    message: GetFrontCameraRosImageResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* kachaka_api.Metadata metadata = 1; */
    if (message.metadata) {
      Metadata.internalBinaryWrite(
        message.metadata,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    }
    /* kachaka_api.RosImage image = 2; */
    if (message.image) {
      RosImage.internalBinaryWrite(
        message.image,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    }
    const u = options.writeUnknownFields;
    if (u !== false) {
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    }
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message kachaka_api.GetFrontCameraRosImageResponse
 */
export const GetFrontCameraRosImageResponse =
  new GetFrontCameraRosImageResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetFrontCameraRosCompressedImageResponse$Type extends MessageType<GetFrontCameraRosCompressedImageResponse> {
  constructor() {
    super('kachaka_api.GetFrontCameraRosCompressedImageResponse', [
      { no: 1, name: 'metadata', kind: 'message', T: () => Metadata },
      { no: 2, name: 'image', kind: 'message', T: () => RosCompressedImage },
    ]);
  }

  create(
    value?: PartialMessage<GetFrontCameraRosCompressedImageResponse>,
  ): GetFrontCameraRosCompressedImageResponse {
    const message = {};
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined) {
      reflectionMergePartial<GetFrontCameraRosCompressedImageResponse>(
        this,
        message,
        value,
      );
    }
    return message;
  }

  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: GetFrontCameraRosCompressedImageResponse,
  ): GetFrontCameraRosCompressedImageResponse {
    const message = target ?? this.create();
    const end = reader.pos + length;
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* kachaka_api.Metadata metadata */ 1:
          message.metadata = Metadata.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.metadata,
          );
          break;
        case /* kachaka_api.RosCompressedImage image */ 2:
          message.image = RosCompressedImage.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.image,
          );
          break;
        default:
          const u = options.readUnknownField;
          if (u === 'throw') {
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          }
          const d = reader.skip(wireType);
          if (u !== false) {
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
          }
      }
    }
    return message;
  }

  internalBinaryWrite(
    message: GetFrontCameraRosCompressedImageResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* kachaka_api.Metadata metadata = 1; */
    if (message.metadata) {
      Metadata.internalBinaryWrite(
        message.metadata,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    }
    /* kachaka_api.RosCompressedImage image = 2; */
    if (message.image) {
      RosCompressedImage.internalBinaryWrite(
        message.image,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    }
    const u = options.writeUnknownFields;
    if (u !== false) {
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    }
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message kachaka_api.GetFrontCameraRosCompressedImageResponse
 */
export const GetFrontCameraRosCompressedImageResponse =
  new GetFrontCameraRosCompressedImageResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StartCommandRequest$Type extends MessageType<StartCommandRequest> {
  constructor() {
    super('kachaka_api.StartCommandRequest', [
      { no: 1, name: 'command', kind: 'message', T: () => Command },
      { no: 2, name: 'cancel_all', kind: 'scalar', T: 8 /* ScalarType.BOOL */ },
      {
        no: 3,
        name: 'tts_on_success',
        kind: 'scalar',
        T: 9 /* ScalarType.STRING */,
      },
      { no: 4, name: 'title', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    ]);
  }

  create(value?: PartialMessage<StartCommandRequest>): StartCommandRequest {
    const message = { cancelAll: false, ttsOnSuccess: '', title: '' };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined) {
      reflectionMergePartial<StartCommandRequest>(this, message, value);
    }
    return message;
  }

  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: StartCommandRequest,
  ): StartCommandRequest {
    const message = target ?? this.create();
    const end = reader.pos + length;
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* kachaka_api.Command command */ 1:
          message.command = Command.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.command,
          );
          break;
        case /* bool cancel_all */ 2:
          message.cancelAll = reader.bool();
          break;
        case /* string tts_on_success */ 3:
          message.ttsOnSuccess = reader.string();
          break;
        case /* string title */ 4:
          message.title = reader.string();
          break;
        default:
          const u = options.readUnknownField;
          if (u === 'throw') {
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          }
          const d = reader.skip(wireType);
          if (u !== false) {
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
          }
      }
    }
    return message;
  }

  internalBinaryWrite(
    message: StartCommandRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* kachaka_api.Command command = 1; */
    if (message.command) {
      Command.internalBinaryWrite(
        message.command,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    }
    /* bool cancel_all = 2; */
    if (message.cancelAll) {
      writer.tag(2, WireType.Varint).bool(message.cancelAll);
    }
    /* string tts_on_success = 3; */
    if (message.ttsOnSuccess !== '') {
      writer.tag(3, WireType.LengthDelimited).string(message.ttsOnSuccess);
    }
    /* string title = 4; */
    if (message.title !== '') {
      writer.tag(4, WireType.LengthDelimited).string(message.title);
    }
    const u = options.writeUnknownFields;
    if (u !== false) {
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    }
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message kachaka_api.StartCommandRequest
 */
export const StartCommandRequest = new StartCommandRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StartCommandResponse$Type extends MessageType<StartCommandResponse> {
  constructor() {
    super('kachaka_api.StartCommandResponse', [
      { no: 1, name: 'result', kind: 'message', T: () => Result },
      {
        no: 2,
        name: 'command_id',
        kind: 'scalar',
        T: 9 /* ScalarType.STRING */,
      },
    ]);
  }

  create(value?: PartialMessage<StartCommandResponse>): StartCommandResponse {
    const message = { commandId: '' };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined) {
      reflectionMergePartial<StartCommandResponse>(this, message, value);
    }
    return message;
  }

  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: StartCommandResponse,
  ): StartCommandResponse {
    const message = target ?? this.create();
    const end = reader.pos + length;
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* kachaka_api.Result result */ 1:
          message.result = Result.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.result,
          );
          break;
        case /* string command_id */ 2:
          message.commandId = reader.string();
          break;
        default:
          const u = options.readUnknownField;
          if (u === 'throw') {
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          }
          const d = reader.skip(wireType);
          if (u !== false) {
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
          }
      }
    }
    return message;
  }

  internalBinaryWrite(
    message: StartCommandResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* kachaka_api.Result result = 1; */
    if (message.result) {
      Result.internalBinaryWrite(
        message.result,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    }
    /* string command_id = 2; */
    if (message.commandId !== '') {
      writer.tag(2, WireType.LengthDelimited).string(message.commandId);
    }
    const u = options.writeUnknownFields;
    if (u !== false) {
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    }
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message kachaka_api.StartCommandResponse
 */
export const StartCommandResponse = new StartCommandResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CancelCommandResponse$Type extends MessageType<CancelCommandResponse> {
  constructor() {
    super('kachaka_api.CancelCommandResponse', [
      { no: 1, name: 'result', kind: 'message', T: () => Result },
      { no: 2, name: 'command', kind: 'message', T: () => Command },
    ]);
  }

  create(value?: PartialMessage<CancelCommandResponse>): CancelCommandResponse {
    const message = {};
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined) {
      reflectionMergePartial<CancelCommandResponse>(this, message, value);
    }
    return message;
  }

  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CancelCommandResponse,
  ): CancelCommandResponse {
    const message = target ?? this.create();
    const end = reader.pos + length;
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* kachaka_api.Result result */ 1:
          message.result = Result.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.result,
          );
          break;
        case /* kachaka_api.Command command */ 2:
          message.command = Command.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.command,
          );
          break;
        default:
          const u = options.readUnknownField;
          if (u === 'throw') {
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          }
          const d = reader.skip(wireType);
          if (u !== false) {
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
          }
      }
    }
    return message;
  }

  internalBinaryWrite(
    message: CancelCommandResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* kachaka_api.Result result = 1; */
    if (message.result) {
      Result.internalBinaryWrite(
        message.result,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    }
    /* kachaka_api.Command command = 2; */
    if (message.command) {
      Command.internalBinaryWrite(
        message.command,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    }
    const u = options.writeUnknownFields;
    if (u !== false) {
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    }
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message kachaka_api.CancelCommandResponse
 */
export const CancelCommandResponse = new CancelCommandResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetCommandStateResponse$Type extends MessageType<GetCommandStateResponse> {
  constructor() {
    super('kachaka_api.GetCommandStateResponse', [
      { no: 1, name: 'metadata', kind: 'message', T: () => Metadata },
      {
        no: 2,
        name: 'state',
        kind: 'enum',
        T: () => ['kachaka_api.CommandState', CommandState, 'COMMAND_STATE_'],
      },
      { no: 3, name: 'command', kind: 'message', T: () => Command },
    ]);
  }

  create(
    value?: PartialMessage<GetCommandStateResponse>,
  ): GetCommandStateResponse {
    const message = { state: 0 };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined) {
      reflectionMergePartial<GetCommandStateResponse>(this, message, value);
    }
    return message;
  }

  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: GetCommandStateResponse,
  ): GetCommandStateResponse {
    const message = target ?? this.create();
    const end = reader.pos + length;
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* kachaka_api.Metadata metadata */ 1:
          message.metadata = Metadata.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.metadata,
          );
          break;
        case /* kachaka_api.CommandState state */ 2:
          message.state = reader.int32();
          break;
        case /* kachaka_api.Command command */ 3:
          message.command = Command.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.command,
          );
          break;
        default:
          const u = options.readUnknownField;
          if (u === 'throw') {
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          }
          const d = reader.skip(wireType);
          if (u !== false) {
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
          }
      }
    }
    return message;
  }

  internalBinaryWrite(
    message: GetCommandStateResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* kachaka_api.Metadata metadata = 1; */
    if (message.metadata) {
      Metadata.internalBinaryWrite(
        message.metadata,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    }
    /* kachaka_api.CommandState state = 2; */
    if (message.state !== 0) {
      writer.tag(2, WireType.Varint).int32(message.state);
    }
    /* kachaka_api.Command command = 3; */
    if (message.command) {
      Command.internalBinaryWrite(
        message.command,
        writer.tag(3, WireType.LengthDelimited).fork(),
        options,
      ).join();
    }
    const u = options.writeUnknownFields;
    if (u !== false) {
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    }
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message kachaka_api.GetCommandStateResponse
 */
export const GetCommandStateResponse = new GetCommandStateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetLastCommandResultResponse$Type extends MessageType<GetLastCommandResultResponse> {
  constructor() {
    super('kachaka_api.GetLastCommandResultResponse', [
      { no: 1, name: 'metadata', kind: 'message', T: () => Metadata },
      { no: 2, name: 'result', kind: 'message', T: () => Result },
      { no: 3, name: 'command', kind: 'message', T: () => Command },
    ]);
  }

  create(
    value?: PartialMessage<GetLastCommandResultResponse>,
  ): GetLastCommandResultResponse {
    const message = {};
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined) {
      reflectionMergePartial<GetLastCommandResultResponse>(
        this,
        message,
        value,
      );
    }
    return message;
  }

  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: GetLastCommandResultResponse,
  ): GetLastCommandResultResponse {
    const message = target ?? this.create();
    const end = reader.pos + length;
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* kachaka_api.Metadata metadata */ 1:
          message.metadata = Metadata.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.metadata,
          );
          break;
        case /* kachaka_api.Result result */ 2:
          message.result = Result.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.result,
          );
          break;
        case /* kachaka_api.Command command */ 3:
          message.command = Command.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.command,
          );
          break;
        default:
          const u = options.readUnknownField;
          if (u === 'throw') {
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          }
          const d = reader.skip(wireType);
          if (u !== false) {
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
          }
      }
    }
    return message;
  }

  internalBinaryWrite(
    message: GetLastCommandResultResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* kachaka_api.Metadata metadata = 1; */
    if (message.metadata) {
      Metadata.internalBinaryWrite(
        message.metadata,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    }
    /* kachaka_api.Result result = 2; */
    if (message.result) {
      Result.internalBinaryWrite(
        message.result,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    }
    /* kachaka_api.Command command = 3; */
    if (message.command) {
      Command.internalBinaryWrite(
        message.command,
        writer.tag(3, WireType.LengthDelimited).fork(),
        options,
      ).join();
    }
    const u = options.writeUnknownFields;
    if (u !== false) {
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    }
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message kachaka_api.GetLastCommandResultResponse
 */
export const GetLastCommandResultResponse =
  new GetLastCommandResultResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetLocationsResponse$Type extends MessageType<GetLocationsResponse> {
  constructor() {
    super('kachaka_api.GetLocationsResponse', [
      { no: 1, name: 'metadata', kind: 'message', T: () => Metadata },
      {
        no: 2,
        name: 'locations',
        kind: 'message',
        repeat: 1 /* RepeatType.PACKED */,
        T: () => Location,
      },
      {
        no: 3,
        name: 'default_location_id',
        kind: 'scalar',
        T: 9 /* ScalarType.STRING */,
      },
    ]);
  }

  create(value?: PartialMessage<GetLocationsResponse>): GetLocationsResponse {
    const message = { locations: [], defaultLocationId: '' };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined) {
      reflectionMergePartial<GetLocationsResponse>(this, message, value);
    }
    return message;
  }

  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: GetLocationsResponse,
  ): GetLocationsResponse {
    const message = target ?? this.create();
    const end = reader.pos + length;
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* kachaka_api.Metadata metadata */ 1:
          message.metadata = Metadata.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.metadata,
          );
          break;
        case /* repeated kachaka_api.Location locations */ 2:
          message.locations.push(
            Location.internalBinaryRead(reader, reader.uint32(), options),
          );
          break;
        case /* string default_location_id */ 3:
          message.defaultLocationId = reader.string();
          break;
        default:
          const u = options.readUnknownField;
          if (u === 'throw') {
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          }
          const d = reader.skip(wireType);
          if (u !== false) {
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
          }
      }
    }
    return message;
  }

  internalBinaryWrite(
    message: GetLocationsResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* kachaka_api.Metadata metadata = 1; */
    if (message.metadata) {
      Metadata.internalBinaryWrite(
        message.metadata,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    }
    /* repeated kachaka_api.Location locations = 2; */
    for (let i = 0; i < message.locations.length; i++) {
      Location.internalBinaryWrite(
        message.locations[i],
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    }
    /* string default_location_id = 3; */
    if (message.defaultLocationId !== '') {
      writer.tag(3, WireType.LengthDelimited).string(message.defaultLocationId);
    }
    const u = options.writeUnknownFields;
    if (u !== false) {
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    }
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message kachaka_api.GetLocationsResponse
 */
export const GetLocationsResponse = new GetLocationsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetShelvesResponse$Type extends MessageType<GetShelvesResponse> {
  constructor() {
    super('kachaka_api.GetShelvesResponse', [
      { no: 1, name: 'metadata', kind: 'message', T: () => Metadata },
      {
        no: 2,
        name: 'shelves',
        kind: 'message',
        repeat: 1 /* RepeatType.PACKED */,
        T: () => Shelf,
      },
    ]);
  }

  create(value?: PartialMessage<GetShelvesResponse>): GetShelvesResponse {
    const message = { shelves: [] };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined) {
      reflectionMergePartial<GetShelvesResponse>(this, message, value);
    }
    return message;
  }

  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: GetShelvesResponse,
  ): GetShelvesResponse {
    const message = target ?? this.create();
    const end = reader.pos + length;
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* kachaka_api.Metadata metadata */ 1:
          message.metadata = Metadata.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.metadata,
          );
          break;
        case /* repeated kachaka_api.Shelf shelves */ 2:
          message.shelves.push(
            Shelf.internalBinaryRead(reader, reader.uint32(), options),
          );
          break;
        default:
          const u = options.readUnknownField;
          if (u === 'throw') {
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          }
          const d = reader.skip(wireType);
          if (u !== false) {
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
          }
      }
    }
    return message;
  }

  internalBinaryWrite(
    message: GetShelvesResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* kachaka_api.Metadata metadata = 1; */
    if (message.metadata) {
      Metadata.internalBinaryWrite(
        message.metadata,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    }
    /* repeated kachaka_api.Shelf shelves = 2; */
    for (let i = 0; i < message.shelves.length; i++) {
      Shelf.internalBinaryWrite(
        message.shelves[i],
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    }
    const u = options.writeUnknownFields;
    if (u !== false) {
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    }
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message kachaka_api.GetShelvesResponse
 */
export const GetShelvesResponse = new GetShelvesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetAutoHomingEnabledRequest$Type extends MessageType<SetAutoHomingEnabledRequest> {
  constructor() {
    super('kachaka_api.SetAutoHomingEnabledRequest', [
      { no: 1, name: 'enable', kind: 'scalar', T: 8 /* ScalarType.BOOL */ },
    ]);
  }

  create(
    value?: PartialMessage<SetAutoHomingEnabledRequest>,
  ): SetAutoHomingEnabledRequest {
    const message = { enable: false };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined) {
      reflectionMergePartial<SetAutoHomingEnabledRequest>(this, message, value);
    }
    return message;
  }

  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: SetAutoHomingEnabledRequest,
  ): SetAutoHomingEnabledRequest {
    const message = target ?? this.create();
    const end = reader.pos + length;
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bool enable */ 1:
          message.enable = reader.bool();
          break;
        default:
          const u = options.readUnknownField;
          if (u === 'throw') {
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          }
          const d = reader.skip(wireType);
          if (u !== false) {
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
          }
      }
    }
    return message;
  }

  internalBinaryWrite(
    message: SetAutoHomingEnabledRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* bool enable = 1; */
    if (message.enable) {
      writer.tag(1, WireType.Varint).bool(message.enable);
    }
    const u = options.writeUnknownFields;
    if (u !== false) {
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    }
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message kachaka_api.SetAutoHomingEnabledRequest
 */
export const SetAutoHomingEnabledRequest =
  new SetAutoHomingEnabledRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetAutoHomingEnabledResponse$Type extends MessageType<SetAutoHomingEnabledResponse> {
  constructor() {
    super('kachaka_api.SetAutoHomingEnabledResponse', [
      { no: 1, name: 'result', kind: 'message', T: () => Result },
    ]);
  }

  create(
    value?: PartialMessage<SetAutoHomingEnabledResponse>,
  ): SetAutoHomingEnabledResponse {
    const message = {};
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined) {
      reflectionMergePartial<SetAutoHomingEnabledResponse>(
        this,
        message,
        value,
      );
    }
    return message;
  }

  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: SetAutoHomingEnabledResponse,
  ): SetAutoHomingEnabledResponse {
    const message = target ?? this.create();
    const end = reader.pos + length;
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* kachaka_api.Result result */ 1:
          message.result = Result.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.result,
          );
          break;
        default:
          const u = options.readUnknownField;
          if (u === 'throw') {
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          }
          const d = reader.skip(wireType);
          if (u !== false) {
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
          }
      }
    }
    return message;
  }

  internalBinaryWrite(
    message: SetAutoHomingEnabledResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* kachaka_api.Result result = 1; */
    if (message.result) {
      Result.internalBinaryWrite(
        message.result,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    }
    const u = options.writeUnknownFields;
    if (u !== false) {
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    }
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message kachaka_api.SetAutoHomingEnabledResponse
 */
export const SetAutoHomingEnabledResponse =
  new SetAutoHomingEnabledResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetAutoHomingEnabledResponse$Type extends MessageType<GetAutoHomingEnabledResponse> {
  constructor() {
    super('kachaka_api.GetAutoHomingEnabledResponse', [
      { no: 1, name: 'metadata', kind: 'message', T: () => Metadata },
      { no: 2, name: 'enabled', kind: 'scalar', T: 8 /* ScalarType.BOOL */ },
    ]);
  }

  create(
    value?: PartialMessage<GetAutoHomingEnabledResponse>,
  ): GetAutoHomingEnabledResponse {
    const message = { enabled: false };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined) {
      reflectionMergePartial<GetAutoHomingEnabledResponse>(
        this,
        message,
        value,
      );
    }
    return message;
  }

  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: GetAutoHomingEnabledResponse,
  ): GetAutoHomingEnabledResponse {
    const message = target ?? this.create();
    const end = reader.pos + length;
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* kachaka_api.Metadata metadata */ 1:
          message.metadata = Metadata.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.metadata,
          );
          break;
        case /* bool enabled */ 2:
          message.enabled = reader.bool();
          break;
        default:
          const u = options.readUnknownField;
          if (u === 'throw') {
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          }
          const d = reader.skip(wireType);
          if (u !== false) {
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
          }
      }
    }
    return message;
  }

  internalBinaryWrite(
    message: GetAutoHomingEnabledResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* kachaka_api.Metadata metadata = 1; */
    if (message.metadata) {
      Metadata.internalBinaryWrite(
        message.metadata,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    }
    /* bool enabled = 2; */
    if (message.enabled) {
      writer.tag(2, WireType.Varint).bool(message.enabled);
    }
    const u = options.writeUnknownFields;
    if (u !== false) {
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    }
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message kachaka_api.GetAutoHomingEnabledResponse
 */
export const GetAutoHomingEnabledResponse =
  new GetAutoHomingEnabledResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetManualControlEnabledRequest$Type extends MessageType<SetManualControlEnabledRequest> {
  constructor() {
    super('kachaka_api.SetManualControlEnabledRequest', [
      { no: 1, name: 'enable', kind: 'scalar', T: 8 /* ScalarType.BOOL */ },
      {
        no: 2,
        name: 'use_shelf_registration',
        kind: 'scalar',
        T: 8 /* ScalarType.BOOL */,
      },
    ]);
  }

  create(
    value?: PartialMessage<SetManualControlEnabledRequest>,
  ): SetManualControlEnabledRequest {
    const message = { enable: false, useShelfRegistration: false };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined) {
      reflectionMergePartial<SetManualControlEnabledRequest>(
        this,
        message,
        value,
      );
    }
    return message;
  }

  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: SetManualControlEnabledRequest,
  ): SetManualControlEnabledRequest {
    const message = target ?? this.create();
    const end = reader.pos + length;
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bool enable */ 1:
          message.enable = reader.bool();
          break;
        case /* bool use_shelf_registration */ 2:
          message.useShelfRegistration = reader.bool();
          break;
        default:
          const u = options.readUnknownField;
          if (u === 'throw') {
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          }
          const d = reader.skip(wireType);
          if (u !== false) {
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
          }
      }
    }
    return message;
  }

  internalBinaryWrite(
    message: SetManualControlEnabledRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* bool enable = 1; */
    if (message.enable) {
      writer.tag(1, WireType.Varint).bool(message.enable);
    }
    /* bool use_shelf_registration = 2; */
    if (message.useShelfRegistration) {
      writer.tag(2, WireType.Varint).bool(message.useShelfRegistration);
    }
    const u = options.writeUnknownFields;
    if (u !== false) {
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    }
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message kachaka_api.SetManualControlEnabledRequest
 */
export const SetManualControlEnabledRequest =
  new SetManualControlEnabledRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetManualControlEnabledResponse$Type extends MessageType<SetManualControlEnabledResponse> {
  constructor() {
    super('kachaka_api.SetManualControlEnabledResponse', [
      { no: 1, name: 'result', kind: 'message', T: () => Result },
    ]);
  }

  create(
    value?: PartialMessage<SetManualControlEnabledResponse>,
  ): SetManualControlEnabledResponse {
    const message = {};
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined) {
      reflectionMergePartial<SetManualControlEnabledResponse>(
        this,
        message,
        value,
      );
    }
    return message;
  }

  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: SetManualControlEnabledResponse,
  ): SetManualControlEnabledResponse {
    const message = target ?? this.create();
    const end = reader.pos + length;
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* kachaka_api.Result result */ 1:
          message.result = Result.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.result,
          );
          break;
        default:
          const u = options.readUnknownField;
          if (u === 'throw') {
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          }
          const d = reader.skip(wireType);
          if (u !== false) {
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
          }
      }
    }
    return message;
  }

  internalBinaryWrite(
    message: SetManualControlEnabledResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* kachaka_api.Result result = 1; */
    if (message.result) {
      Result.internalBinaryWrite(
        message.result,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    }
    const u = options.writeUnknownFields;
    if (u !== false) {
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    }
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message kachaka_api.SetManualControlEnabledResponse
 */
export const SetManualControlEnabledResponse =
  new SetManualControlEnabledResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetManualControlEnabledResponse$Type extends MessageType<GetManualControlEnabledResponse> {
  constructor() {
    super('kachaka_api.GetManualControlEnabledResponse', [
      { no: 1, name: 'metadata', kind: 'message', T: () => Metadata },
      { no: 2, name: 'enabled', kind: 'scalar', T: 8 /* ScalarType.BOOL */ },
    ]);
  }

  create(
    value?: PartialMessage<GetManualControlEnabledResponse>,
  ): GetManualControlEnabledResponse {
    const message = { enabled: false };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined) {
      reflectionMergePartial<GetManualControlEnabledResponse>(
        this,
        message,
        value,
      );
    }
    return message;
  }

  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: GetManualControlEnabledResponse,
  ): GetManualControlEnabledResponse {
    const message = target ?? this.create();
    const end = reader.pos + length;
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* kachaka_api.Metadata metadata */ 1:
          message.metadata = Metadata.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.metadata,
          );
          break;
        case /* bool enabled */ 2:
          message.enabled = reader.bool();
          break;
        default:
          const u = options.readUnknownField;
          if (u === 'throw') {
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          }
          const d = reader.skip(wireType);
          if (u !== false) {
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
          }
      }
    }
    return message;
  }

  internalBinaryWrite(
    message: GetManualControlEnabledResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* kachaka_api.Metadata metadata = 1; */
    if (message.metadata) {
      Metadata.internalBinaryWrite(
        message.metadata,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    }
    /* bool enabled = 2; */
    if (message.enabled) {
      writer.tag(2, WireType.Varint).bool(message.enabled);
    }
    const u = options.writeUnknownFields;
    if (u !== false) {
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    }
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message kachaka_api.GetManualControlEnabledResponse
 */
export const GetManualControlEnabledResponse =
  new GetManualControlEnabledResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetRobotVelocityRequest$Type extends MessageType<SetRobotVelocityRequest> {
  constructor() {
    super('kachaka_api.SetRobotVelocityRequest', [
      { no: 1, name: 'linear', kind: 'scalar', T: 1 /* ScalarType.DOUBLE */ },
      { no: 2, name: 'angular', kind: 'scalar', T: 1 /* ScalarType.DOUBLE */ },
    ]);
  }

  create(
    value?: PartialMessage<SetRobotVelocityRequest>,
  ): SetRobotVelocityRequest {
    const message = { linear: 0, angular: 0 };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined) {
      reflectionMergePartial<SetRobotVelocityRequest>(this, message, value);
    }
    return message;
  }

  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: SetRobotVelocityRequest,
  ): SetRobotVelocityRequest {
    const message = target ?? this.create();
    const end = reader.pos + length;
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* double linear */ 1:
          message.linear = reader.double();
          break;
        case /* double angular */ 2:
          message.angular = reader.double();
          break;
        default:
          const u = options.readUnknownField;
          if (u === 'throw') {
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          }
          const d = reader.skip(wireType);
          if (u !== false) {
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
          }
      }
    }
    return message;
  }

  internalBinaryWrite(
    message: SetRobotVelocityRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* double linear = 1; */
    if (message.linear !== 0) {
      writer.tag(1, WireType.Bit64).double(message.linear);
    }
    /* double angular = 2; */
    if (message.angular !== 0) {
      writer.tag(2, WireType.Bit64).double(message.angular);
    }
    const u = options.writeUnknownFields;
    if (u !== false) {
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    }
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message kachaka_api.SetRobotVelocityRequest
 */
export const SetRobotVelocityRequest = new SetRobotVelocityRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetRobotVelocityResponse$Type extends MessageType<SetRobotVelocityResponse> {
  constructor() {
    super('kachaka_api.SetRobotVelocityResponse', [
      { no: 1, name: 'result', kind: 'message', T: () => Result },
    ]);
  }

  create(
    value?: PartialMessage<SetRobotVelocityResponse>,
  ): SetRobotVelocityResponse {
    const message = {};
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined) {
      reflectionMergePartial<SetRobotVelocityResponse>(this, message, value);
    }
    return message;
  }

  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: SetRobotVelocityResponse,
  ): SetRobotVelocityResponse {
    const message = target ?? this.create();
    const end = reader.pos + length;
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* kachaka_api.Result result */ 1:
          message.result = Result.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.result,
          );
          break;
        default:
          const u = options.readUnknownField;
          if (u === 'throw') {
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          }
          const d = reader.skip(wireType);
          if (u !== false) {
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
          }
      }
    }
    return message;
  }

  internalBinaryWrite(
    message: SetRobotVelocityResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* kachaka_api.Result result = 1; */
    if (message.result) {
      Result.internalBinaryWrite(
        message.result,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    }
    const u = options.writeUnknownFields;
    if (u !== false) {
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    }
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message kachaka_api.SetRobotVelocityResponse
 */
export const SetRobotVelocityResponse = new SetRobotVelocityResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class History$Type extends MessageType<History> {
  constructor() {
    super('kachaka_api.History', [
      { no: 1, name: 'id', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
      { no: 4, name: 'command', kind: 'message', T: () => Command },
      { no: 5, name: 'success', kind: 'scalar', T: 8 /* ScalarType.BOOL */ },
      {
        no: 6,
        name: 'error_code',
        kind: 'scalar',
        T: 5 /* ScalarType.INT32 */,
      },
      {
        no: 7,
        name: 'command_executed_time',
        kind: 'scalar',
        T: 3 /* ScalarType.INT64 */,
        L: 0 /* LongType.BIGINT */,
      },
    ]);
  }

  create(value?: PartialMessage<History>): History {
    const message = {
      id: '',
      success: false,
      errorCode: 0,
      commandExecutedTime: 0n,
    };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined) {
      reflectionMergePartial<History>(this, message, value);
    }
    return message;
  }

  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: History,
  ): History {
    const message = target ?? this.create();
    const end = reader.pos + length;
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string id */ 1:
          message.id = reader.string();
          break;
        case /* kachaka_api.Command command */ 4:
          message.command = Command.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.command,
          );
          break;
        case /* bool success */ 5:
          message.success = reader.bool();
          break;
        case /* int32 error_code */ 6:
          message.errorCode = reader.int32();
          break;
        case /* int64 command_executed_time */ 7:
          message.commandExecutedTime = reader.int64().toBigInt();
          break;
        default:
          const u = options.readUnknownField;
          if (u === 'throw') {
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          }
          const d = reader.skip(wireType);
          if (u !== false) {
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
          }
      }
    }
    return message;
  }

  internalBinaryWrite(
    message: History,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string id = 1; */
    if (message.id !== '') {
      writer.tag(1, WireType.LengthDelimited).string(message.id);
    }
    /* kachaka_api.Command command = 4; */
    if (message.command) {
      Command.internalBinaryWrite(
        message.command,
        writer.tag(4, WireType.LengthDelimited).fork(),
        options,
      ).join();
    }
    /* bool success = 5; */
    if (message.success) {
      writer.tag(5, WireType.Varint).bool(message.success);
    }
    /* int32 error_code = 6; */
    if (message.errorCode !== 0) {
      writer.tag(6, WireType.Varint).int32(message.errorCode);
    }
    /* int64 command_executed_time = 7; */
    if (message.commandExecutedTime !== 0n) {
      writer.tag(7, WireType.Varint).int64(message.commandExecutedTime);
    }
    const u = options.writeUnknownFields;
    if (u !== false) {
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    }
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message kachaka_api.History
 */
export const History = new History$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetHistoryListResponse$Type extends MessageType<GetHistoryListResponse> {
  constructor() {
    super('kachaka_api.GetHistoryListResponse', [
      { no: 1, name: 'metadata', kind: 'message', T: () => Metadata },
      {
        no: 2,
        name: 'histories',
        kind: 'message',
        repeat: 1 /* RepeatType.PACKED */,
        T: () => History,
      },
    ]);
  }

  create(
    value?: PartialMessage<GetHistoryListResponse>,
  ): GetHistoryListResponse {
    const message = { histories: [] };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined) {
      reflectionMergePartial<GetHistoryListResponse>(this, message, value);
    }
    return message;
  }

  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: GetHistoryListResponse,
  ): GetHistoryListResponse {
    const message = target ?? this.create();
    const end = reader.pos + length;
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* kachaka_api.Metadata metadata */ 1:
          message.metadata = Metadata.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.metadata,
          );
          break;
        case /* repeated kachaka_api.History histories */ 2:
          message.histories.push(
            History.internalBinaryRead(reader, reader.uint32(), options),
          );
          break;
        default:
          const u = options.readUnknownField;
          if (u === 'throw') {
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          }
          const d = reader.skip(wireType);
          if (u !== false) {
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
          }
      }
    }
    return message;
  }

  internalBinaryWrite(
    message: GetHistoryListResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* kachaka_api.Metadata metadata = 1; */
    if (message.metadata) {
      Metadata.internalBinaryWrite(
        message.metadata,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    }
    /* repeated kachaka_api.History histories = 2; */
    for (let i = 0; i < message.histories.length; i++) {
      History.internalBinaryWrite(
        message.histories[i],
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    }
    const u = options.writeUnknownFields;
    if (u !== false) {
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    }
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message kachaka_api.GetHistoryListResponse
 */
export const GetHistoryListResponse = new GetHistoryListResponse$Type();
/**
 * @generated ServiceType for protobuf service kachaka_api.KachakaApi
 */
export const KachakaApi = new ServiceType('kachaka_api.KachakaApi', [
  {
    name: 'GetRobotSerialNumber',
    options: {},
    I: GetRequest,
    O: GetRobotSerialNumberResponse,
  },
  {
    name: 'GetRobotVersion',
    options: {},
    I: GetRequest,
    O: GetRobotVersionResponse,
  },
  { name: 'GetRobotPose', options: {}, I: GetRequest, O: GetRobotPoseResponse },
  { name: 'GetPngMap', options: {}, I: GetRequest, O: GetPngMapResponse },
  {
    name: 'GetObjectDetection',
    options: {},
    I: GetRequest,
    O: GetObjectDetectionResponse,
  },
  { name: 'GetRosImu', options: {}, I: GetRequest, O: GetRosImuResponse },
  {
    name: 'GetRosOdometry',
    options: {},
    I: GetRequest,
    O: GetRosOdometryResponse,
  },
  {
    name: 'GetRosLaserScan',
    options: {},
    I: GetRequest,
    O: GetRosLaserScanResponse,
  },
  {
    name: 'GetFrontCameraRosCameraInfo',
    options: {},
    I: GetRequest,
    O: GetFrontCameraRosCameraInfoResponse,
  },
  {
    name: 'GetFrontCameraRosImage',
    options: {},
    I: GetRequest,
    O: GetFrontCameraRosImageResponse,
  },
  {
    name: 'GetFrontCameraRosCompressedImage',
    options: {},
    I: GetRequest,
    O: GetFrontCameraRosCompressedImageResponse,
  },
  {
    name: 'StartCommand',
    options: {},
    I: StartCommandRequest,
    O: StartCommandResponse,
  },
  {
    name: 'CancelCommand',
    options: {},
    I: EmptyRequest,
    O: CancelCommandResponse,
  },
  {
    name: 'GetCommandState',
    options: {},
    I: GetRequest,
    O: GetCommandStateResponse,
  },
  {
    name: 'GetLastCommandResult',
    options: {},
    I: GetRequest,
    O: GetLastCommandResultResponse,
  },
  { name: 'GetLocations', options: {}, I: GetRequest, O: GetLocationsResponse },
  { name: 'GetShelves', options: {}, I: GetRequest, O: GetShelvesResponse },
  {
    name: 'SetAutoHomingEnabled',
    options: {},
    I: SetAutoHomingEnabledRequest,
    O: SetAutoHomingEnabledResponse,
  },
  {
    name: 'GetAutoHomingEnabled',
    options: {},
    I: GetRequest,
    O: GetAutoHomingEnabledResponse,
  },
  {
    name: 'SetManualControlEnabled',
    options: {},
    I: SetManualControlEnabledRequest,
    O: SetManualControlEnabledResponse,
  },
  {
    name: 'GetManualControlEnabled',
    options: {},
    I: GetRequest,
    O: GetManualControlEnabledResponse,
  },
  {
    name: 'SetRobotVelocity',
    options: {},
    I: SetRobotVelocityRequest,
    O: SetRobotVelocityResponse,
  },
  {
    name: 'GetHistoryList',
    options: {},
    I: GetRequest,
    O: GetHistoryListResponse,
  },
]);
